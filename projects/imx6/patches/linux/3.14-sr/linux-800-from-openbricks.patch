https://github.com/OpenBricks/openbricks/tree/krypton-glibc
https://github.com/OpenBricks/openbricks/tree/krypton-glibc/config/platforms/arm/imx6/machines/cuboxi/packages/linux/patches
https://github.com/OpenBricks/openbricks/tree/27322b70e3566434443991078645e6a7395cb28d/config/platforms/arm/imx6/machines/cuboxi/packages/linux/patches

==============================================================
file 0001-MXC-CEC-Remove-superflous-guards-that-could-even-bre.patch
==============================================================

From 90d153b9d46ad06a4a513902d3bb72d23c45bdcc Mon Sep 17 00:00:00 2001
From: wolfgar <stephan.rafin@laposte.net>
Date: Mon, 31 Oct 2016 10:58:44 +0100
Subject: [PATCH] MXC-CEC: Remove superflous guards that could even break
 invocation from mxc-hdmi

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 20 ++------------------
 1 file changed, 2 insertions(+), 18 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index ac70a0c..f787274 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -83,8 +83,6 @@ struct hdmi_cec_event {
 
 static LIST_HEAD(head);
 
-static int hdmi_cec_ready = 0;
-static int hdmi_cec_started;
 static int hdmi_cec_major;
 static struct class *hdmi_cec_class;
 static struct hdmi_cec_priv hdmi_cec_data;
@@ -314,7 +312,7 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 		mutex_unlock(&hdmi_cec_data.lock);
 		return -EACCES;
 	}
-	/* Ensure that there is only one writer who is the only listener of tx_cec_queue */
+	/* Ensure that there is only one writer who is the unique listener of tx_cec_queue */
 	if (hdmi_cec_data.tx_answer != CEC_TX_AVAIL) {
 		mutex_unlock(&hdmi_cec_data.lock);
 		return -EBUSY;
@@ -358,13 +356,11 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	return ret;
 }
 
+
 void hdmi_cec_start_device(void)
 {
 	u8 val;
 
-	if (!hdmi_cec_ready || hdmi_cec_started)
-		return;
-
 	val = hdmi_readb(HDMI_MC_CLKDIS);
 	val &= ~HDMI_MC_CLKDIS_CECCLK_DISABLE;
 	hdmi_writeb(val, HDMI_MC_CLKDIS);
@@ -377,11 +373,7 @@ void hdmi_cec_start_device(void)
 	hdmi_writeb(val, HDMI_CEC_MASK);
 	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
 	hdmi_cec_data.link_status = hdmi_readb(HDMI_PHY_STAT0) & 0x02;
-	mutex_lock(&hdmi_cec_data.lock);
 	hdmi_cec_data.cec_state = true;
-	mutex_unlock(&hdmi_cec_data.lock);
-
-	hdmi_cec_started = 1;
 }
 EXPORT_SYMBOL(hdmi_cec_start_device);
 
@@ -389,9 +381,6 @@ void hdmi_cec_stop_device(void)
 { 
 	u8 val;
 
-	if (!hdmi_cec_ready || !hdmi_cec_started)
-		return;
-
 	hdmi_writeb(0x10, HDMI_CEC_CTRL);
 	val = HDMI_IH_CEC_STAT0_WAKEUP | HDMI_IH_CEC_STAT0_ERROR_FOLL | HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_ARB_LOST | \
 			HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
@@ -401,11 +390,7 @@ void hdmi_cec_stop_device(void)
 	val = hdmi_readb(HDMI_MC_CLKDIS);
 	val |= HDMI_MC_CLKDIS_CECCLK_DISABLE;
 	hdmi_writeb(val, HDMI_MC_CLKDIS);
-	mutex_lock(&hdmi_cec_data.lock);
 	hdmi_cec_data.cec_state = false;
-	mutex_unlock(&hdmi_cec_data.lock);
-
-	hdmi_cec_started = 0;
 }
 EXPORT_SYMBOL(hdmi_cec_stop_device);
 
@@ -579,7 +564,6 @@ static int hdmi_cec_dev_probe(struct platform_device *pdev)
 	INIT_DELAYED_WORK(&hdmi_cec_data.hdmi_cec_work, mxc_hdmi_cec_worker);
 
 	dev_info(&pdev->dev, "HDMI CEC initialized\n");
-	hdmi_cec_ready = 1;
 	goto out;
 
 err_out_class:
-- 
1.9.1


==============================================================
file 0002-MXC-CEC-Flush-pending-events-at-close.patch
==============================================================

From 3309b17795c3c9cc1b457caf154f0f2e87121aa3 Mon Sep 17 00:00:00 2001
From: wolfgar <stephan.rafin@laposte.net>
Date: Mon, 31 Oct 2016 10:59:44 +0100
Subject: [PATCH] MXC-CEC: Flush pending events at close

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index f787274..210d764 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -465,11 +465,18 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
  */
 static int hdmi_cec_release(struct inode *inode, struct file *filp)
 {
+	struct hdmi_cec_event *event, *tmp_event;
 	mutex_lock(&hdmi_cec_data.lock);
 	if (open_count) {
 		open_count = 0;
 		hdmi_cec_data.cec_state = false;
 		hdmi_cec_data.Logical_address = 15;
+
+		/* Flush eventual events which have not been read by user space */
+		list_for_each_entry_safe(event, tmp_event, &head, list) {
+			list_del(&event->list);
+			vfree(event);
+		}
 	}
 	mutex_unlock(&hdmi_cec_data.lock);
 
-- 
1.9.1


==============================================================
file 0003-MXC-CEC-Remove-embedded-logics-from-the-driver-so-th.patch
==============================================================

From 66ca526351cb7fe726e8e7ae19818e09e63fa19d Mon Sep 17 00:00:00 2001
From: wolfgar <stephan.rafin@laposte.net>
Date: Mon, 31 Oct 2016 11:00:46 +0100
Subject: [PATCH] MXC-CEC: Remove embedded logics from the driver so that
 libcec is responsible for all this work

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 34 ++++++----------------------------
 1 file changed, 6 insertions(+), 28 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index 210d764..da34f27 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -132,7 +132,7 @@ static irqreturn_t mxc_hdmi_cec_isr(int irq, void *data)
 
 void mxc_hdmi_cec_handle(u16 cec_stat)
 {
-	u8 val = 0, i = 0;
+	u8 i = 0;
 	struct hdmi_cec_event *event = NULL;
 	/*The current transmission is successful (for initiator only).*/
 	if (!open_count)
@@ -167,27 +167,14 @@ void mxc_hdmi_cec_handle(u16 cec_stat)
 	}
 	/*An error is detected on cec line (for initiator only). */
 	if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_INIT) {
-		mutex_lock(&hdmi_cec_data.lock);
-		hdmi_cec_data.send_error++;
-		if (hdmi_cec_data.send_error > 2) {
-			pr_err("%s:Re-transmission is attempted more than 2 times!\n", __func__);
-			hdmi_cec_data.send_error = 0;
-			mutex_unlock(&hdmi_cec_data.lock);
-			hdmi_cec_data.tx_answer = cec_stat;
-			wake_up(&tx_cec_queue);
-			return;
-		}
-		for (i = 0; i < hdmi_cec_data.msg_len; i++)
-			hdmi_writeb(hdmi_cec_data.last_msg[i], HDMI_CEC_TX_DATA0+i);
-		hdmi_writeb(hdmi_cec_data.msg_len, HDMI_CEC_TX_CNT);
-		val = hdmi_readb(HDMI_CEC_CTRL);
-		val |= 0x01;
-		hdmi_writeb(val, HDMI_CEC_CTRL);
-		mutex_unlock(&hdmi_cec_data.lock);
+		hdmi_cec_data.tx_answer = cec_stat;
+		wake_up(&tx_cec_queue);
+		return;
 	}
 	/*A frame is not acknowledged in a directly addressed message. Or a frame is negatively acknowledged in
 	a broadcast message (for initiator only).*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_NACK) {
+		hdmi_cec_data.send_error++;
 		hdmi_cec_data.tx_answer = cec_stat;
 		wake_up(&tx_cec_queue);
 	}
@@ -403,7 +390,7 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 		     u_long arg)
 {
 	int ret = 0, status = 0;
-	u8 val = 0, msg = 0;
+	u8 val = 0;
 	struct mxc_edid_cfg hdmi_edid_cfg;
 	pr_debug("function : %s\n", __func__);
 	if (!open_count)
@@ -427,15 +414,6 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 			hdmi_writeb(0, HDMI_CEC_ADDR_L);
 		} else
 			ret = -EINVAL;
-		/*Send Polling message with same source and destination address*/
-		if (0 == ret && 15 != hdmi_cec_data.Logical_address) {
-			msg = (hdmi_cec_data.Logical_address << 4)|hdmi_cec_data.Logical_address;
-			hdmi_writeb(1, HDMI_CEC_TX_CNT);
-			hdmi_writeb(msg, HDMI_CEC_TX_DATA0);
-			val = hdmi_readb(HDMI_CEC_CTRL);
-			val |= 0x01;
-			hdmi_writeb(val, HDMI_CEC_CTRL);
-		}
 		mutex_unlock(&hdmi_cec_data.lock);
 		break;
 	case HDMICEC_IOC_STARTDEVICE:
-- 
1.9.1


==============================================================
file 0004-MXC-CEC-Remove-some-more-unneeded-guards-variables-a.patch
==============================================================

From 6e0fb54a084d886f1c55660485bbdde3dea57057 Mon Sep 17 00:00:00 2001
From: warped-rudi <r.ihle@s-t.de>
Date: Wed, 9 Nov 2016 09:27:37 +0100
Subject: [PATCH] MXC-CEC: Remove some more unneeded guards, variables and
 comments

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 82 ++++++++++++++-----------------------
 1 file changed, 31 insertions(+), 51 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index da34f27..ffaf20c 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -47,24 +47,22 @@
 #include "mxc_hdmi-cec.h"
 
 
-#define MAX_MESSAGE_LEN		17
+#define MAX_MESSAGE_LEN			17
 
-#define MESSAGE_TYPE_RECEIVE_SUCCESS		1
+#define MESSAGE_TYPE_RECEIVE_SUCCESS	1
 #define MESSAGE_TYPE_NOACK		2
-#define MESSAGE_TYPE_DISCONNECTED		3
+#define MESSAGE_TYPE_DISCONNECTED	3
 #define MESSAGE_TYPE_CONNECTED		4
-#define MESSAGE_TYPE_SEND_SUCCESS		5
+#define MESSAGE_TYPE_SEND_SUCCESS	5
 
-#define CEC_TX_INPROGRESS -1
-#define CEC_TX_AVAIL 0
+#define CEC_TX_INPROGRESS		-1
+#define CEC_TX_AVAIL			0
 
 struct hdmi_cec_priv {
 	int  receive_error;
 	int  send_error;
 	u8 Logical_address;
 	bool cec_state;
-	u8 last_msg[MAX_MESSAGE_LEN];
-	u8 msg_len;
 	int tx_answer;
 	u16 latest_cec_stat;
 	u8 link_status;
@@ -223,11 +221,6 @@ static void mxc_hdmi_cec_worker(struct work_struct *work)
 	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
 }
 
-/*!
- * @brief open function for cec file operation
- *
- * @return  0 on success or negative error code on error
- */
 static int hdmi_cec_open(struct inode *inode, struct file *filp)
 {
 	mutex_lock(&hdmi_cec_data.lock);
@@ -247,10 +240,9 @@ static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 			    loff_t *ppos)
 {
 	struct hdmi_cec_event *event = NULL;
+
 	pr_debug("function : %s\n", __func__);
 
-	if (!open_count)
-		return -ENODEV;
 	mutex_lock(&hdmi_cec_data.lock);
 	if (false == hdmi_cec_data.cec_state) {
 		mutex_unlock(&hdmi_cec_data.lock);
@@ -292,8 +284,6 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 
 	pr_debug("function : %s\n", __func__);
 
-	if (!open_count)
-		return -ENODEV;
 	mutex_lock(&hdmi_cec_data.lock);
 	if (false == hdmi_cec_data.cec_state) {
 		mutex_unlock(&hdmi_cec_data.lock);
@@ -321,8 +311,6 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	val = hdmi_readb(HDMI_CEC_CTRL);
 	val |= 0x01;
 	hdmi_writeb(val, HDMI_CEC_CTRL);
-	memcpy(hdmi_cec_data.last_msg, msg, msg_len);
-	hdmi_cec_data.msg_len = msg_len;
 	mutex_unlock(&hdmi_cec_data.lock);
 
 	ret = wait_event_interruptible_timeout(tx_cec_queue, hdmi_cec_data.tx_answer != CEC_TX_INPROGRESS, HZ);
@@ -336,9 +324,9 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 		/* msg correctly sent */
 		ret = msg_len;
 	else
-		ret =  -EIO;
+		ret = -EIO;
 
-	tx_out:
+tx_out:
 	hdmi_cec_data.tx_answer = CEC_TX_AVAIL;
 	return ret;
 }
@@ -381,20 +369,15 @@ void hdmi_cec_stop_device(void)
 }
 EXPORT_SYMBOL(hdmi_cec_stop_device);
 
-/*!
- * @brief IO ctrl function for vpu file operation
- * @param cmd IO ctrl command
- * @return  0 on success or negative error code on error
- */
 static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 		     u_long arg)
 {
 	int ret = 0, status = 0;
 	u8 val = 0;
 	struct mxc_edid_cfg hdmi_edid_cfg;
+
 	pr_debug("function : %s\n", __func__);
-	if (!open_count)
-		return -ENODEV;
+
 	switch (cmd) {
 	case HDMICEC_IOC_SETLOGICALADDRESS:
 		mutex_lock(&hdmi_cec_data.lock);
@@ -437,13 +420,12 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
     return ret;
 }
 
-/*!
- * @brief Release function for vpu file operation
- * @return  0 on success or negative error code on error
- */
 static int hdmi_cec_release(struct inode *inode, struct file *filp)
 {
 	struct hdmi_cec_event *event, *tmp_event;
+
+	pr_debug("function : %s\n", __func__);
+
 	mutex_lock(&hdmi_cec_data.lock);
 	if (open_count) {
 		open_count = 0;
@@ -473,7 +455,7 @@ static unsigned int hdmi_cec_poll(struct file *file, poll_table *wait)
 	mask =  (POLLOUT | POLLWRNORM);
 	mutex_lock(&hdmi_cec_data.lock);
 	if (!list_empty(&head))
-			mask |= (POLLIN | POLLRDNORM);
+		mask |= (POLLIN | POLLRDNORM);
 	mutex_unlock(&hdmi_cec_data.lock);
 	return mask;
 }
@@ -499,14 +481,14 @@ static int hdmi_cec_dev_probe(struct platform_device *pdev)
 
 	hdmi_cec_major = register_chrdev(hdmi_cec_major, "mxc_hdmi_cec", &hdmi_cec_fops);
 	if (hdmi_cec_major < 0) {
-		dev_err(&pdev->dev, "hdmi_cec: unable to get a major for HDMI CEC\n");
+		dev_err(&pdev->dev, "Unable to get a major for HDMI CEC\n");
 		err = -EBUSY;
 		goto out;
 	}
 	
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (unlikely(res == NULL)) {
-		dev_err(&pdev->dev, "hdmi_cec:No HDMI irq line provided\n");
+		dev_err(&pdev->dev, "No HDMI irq line provided\n");
 		goto err_out_chrdev;
 	}
 	spin_lock_init(&hdmi_cec_data.irq_lock);
@@ -514,7 +496,7 @@ static int hdmi_cec_dev_probe(struct platform_device *pdev)
 	err = devm_request_irq(&pdev->dev, irq, mxc_hdmi_cec_isr, IRQF_SHARED,
 			dev_name(&pdev->dev), &hdmi_cec_data);
 	if (err < 0) {
-		dev_err(&pdev->dev, "hdmi_cec:Unable to request irq: %d\n", err);
+		dev_err(&pdev->dev, "Unable to request irq: %d\n", err);
 		goto err_out_chrdev;
 	}
 
@@ -524,8 +506,8 @@ static int hdmi_cec_dev_probe(struct platform_device *pdev)
 		goto err_out_chrdev;
 	}
 
-	temp_class = device_create(hdmi_cec_class, NULL, MKDEV(hdmi_cec_major, 0),
-														 NULL, "mxc_hdmi_cec");
+	temp_class = device_create(hdmi_cec_class, NULL,
+				   MKDEV(hdmi_cec_major, 0), NULL, "mxc_hdmi_cec");
 	if (IS_ERR(temp_class)) {
 		err = PTR_ERR(temp_class);
 		goto err_out_class;
@@ -533,7 +515,7 @@ static int hdmi_cec_dev_probe(struct platform_device *pdev)
 
 	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
 	if (IS_ERR(pinctrl)) {
-		dev_err(&pdev->dev, "can't get/select CEC pinctrl\n");
+		dev_err(&pdev->dev, "Can't get/select CEC pinctrl\n");
 		goto err_out_class;
 	}
 
@@ -562,14 +544,13 @@ out:
 
 static int hdmi_cec_dev_remove(struct platform_device *pdev)
 {
-	if (hdmi_cec_data.cec_state)
-		hdmi_cec_stop_device();
-	if (hdmi_cec_major > 0) {
-		device_destroy(hdmi_cec_class, MKDEV(hdmi_cec_major, 0));
-		class_destroy(hdmi_cec_class);
-		unregister_chrdev(hdmi_cec_major, "mxc_hdmi_cec");
-		hdmi_cec_major = 0;
-}
+	hdmi_cec_stop_device();
+
+	device_destroy(hdmi_cec_class, MKDEV(hdmi_cec_major, 0));
+	class_destroy(hdmi_cec_class);
+	unregister_chrdev(hdmi_cec_major, "mxc_hdmi_cec");
+	hdmi_cec_major = 0;
+
 	return 0;
 }
 
@@ -583,9 +564,9 @@ static struct platform_driver mxc_hdmi_cec_driver = {
 	.probe = hdmi_cec_dev_probe,
 	.remove = hdmi_cec_dev_remove,
 	.driver = {
-		   .name = "mxc_hdmi_cec",
-		.of_match_table	= imx_hdmi_cec_match,
-		   },
+		.name = "mxc_hdmi_cec",
+		.of_match_table = imx_hdmi_cec_match,
+	},
 };
 
 module_platform_driver(mxc_hdmi_cec_driver);
@@ -594,4 +575,3 @@ MODULE_AUTHOR("Freescale Semiconductor, Inc.");
 MODULE_DESCRIPTION("Linux HDMI CEC driver for Freescale i.MX/MXC");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:mxc_hdmi_cec");
-
-- 
1.9.1


==============================================================
file 0005-MXC-CEC-Restructure-code-to-avoid-race-conditions.patch
==============================================================

From 52969de0f8a8afb87ccc43fe568e11f9a3cfccdf Mon Sep 17 00:00:00 2001
From: warped-rudi <r.ihle@s-t.de>
Date: Wed, 9 Nov 2016 09:27:38 +0100
Subject: [PATCH] MXC-CEC: Restructure code to avoid race conditions

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 258 ++++++++++++++++++++++++------------
 drivers/video/mxc/mxc_hdmi.c        |   7 +-
 include/linux/mfd/mxc-hdmi-core.h   |   1 +
 3 files changed, 175 insertions(+), 91 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index ffaf20c..f62bcbc 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -58,16 +58,32 @@
 #define CEC_TX_INPROGRESS		-1
 #define CEC_TX_AVAIL			0
 
+/* These flags must not collide with HDMI_IH_CEC_STAT0_xxxx */
+#define	CEC_STAT0_EX_CONNECTED		0x0100
+#define	CEC_STAT0_EX_DISCONNECTED	0x0200
+
+#define	CEC_STAT0_MASK_ALL	(HDMI_IH_CEC_STAT0_WAKEUP | \
+				 HDMI_IH_CEC_STAT0_ERROR_FOLL | \
+				 HDMI_IH_CEC_STAT0_ARB_LOST | \
+				 HDMI_IH_CEC_STAT0_ERROR_INIT | \
+				 HDMI_IH_CEC_STAT0_NACK | \
+				 HDMI_IH_CEC_STAT0_EOM | \
+				 HDMI_IH_CEC_STAT0_DONE)
+
+#define	CEC_STAT0_MASK_DEFAULT	(HDMI_IH_CEC_STAT0_WAKEUP | \
+				 HDMI_IH_CEC_STAT0_ERROR_FOLL | \
+				 HDMI_IH_CEC_STAT0_ARB_LOST)
+
 struct hdmi_cec_priv {
 	int  receive_error;
 	int  send_error;
 	u8 Logical_address;
-	bool cec_state;
+	u8 cec_state;
 	int tx_answer;
-	u16 latest_cec_stat;
+	u32 cec_stat0;
 	u8 link_status;
 	spinlock_t irq_lock;
-	struct delayed_work hdmi_cec_work;
+	struct work_struct hdmi_cec_work;
 	struct mutex lock;
 };
 
@@ -81,68 +97,79 @@ struct hdmi_cec_event {
 
 static LIST_HEAD(head);
 
+static int hdmi_cec_irq;
 static int hdmi_cec_major;
 static struct class *hdmi_cec_class;
 static struct hdmi_cec_priv hdmi_cec_data;
 static u8 open_count;
+static u8 want_start;
+static u8 link_status;
+static u8 is_initialized;
 
 static wait_queue_head_t hdmi_cec_queue;
 static wait_queue_head_t tx_cec_queue;
 
+
+static u32 get_hpd_stat(struct hdmi_cec_priv *hdmi_cec)
+{
+	u32 cec_stat0 = 0;
+
+	if (hdmi_cec->link_status ^ link_status) {
+		hdmi_cec->link_status = link_status;
+		if (hdmi_cec->link_status)
+			cec_stat0 = CEC_STAT0_EX_CONNECTED;
+		else
+			cec_stat0 = CEC_STAT0_EX_DISCONNECTED;
+	}
+
+	return cec_stat0;
+}
+
 static irqreturn_t mxc_hdmi_cec_isr(int irq, void *data)
 {
 	struct hdmi_cec_priv *hdmi_cec = data;
-	u16 cec_stat = 0;
 	unsigned long flags;
-	u8 phy_stat0;
+	u8 cec_stat;
 
 	spin_lock_irqsave(&hdmi_cec->irq_lock, flags);
 
-	hdmi_writeb(0x7f, HDMI_IH_MUTE_CEC_STAT0);
+	hdmi_writeb(CEC_STAT0_MASK_ALL, HDMI_IH_MUTE_CEC_STAT0);
 
-	cec_stat = hdmi_readb(HDMI_IH_CEC_STAT0);
+	cec_stat = hdmi_readb(HDMI_IH_CEC_STAT0) & CEC_STAT0_MASK_ALL;
 	hdmi_writeb(cec_stat, HDMI_IH_CEC_STAT0);
-	phy_stat0 = hdmi_readb(HDMI_PHY_STAT0) & 0x02;
-	if (hdmi_cec->link_status ^ phy_stat0) {
-		/* HPD value changed */
-		hdmi_cec->link_status = phy_stat0;
-		if (hdmi_cec->link_status)
-			cec_stat |= 0x80; /* Connected */
-		else
-			cec_stat |= 0x100; /* Disconnected */
-	}
-	if ((cec_stat & (HDMI_IH_CEC_STAT0_ERROR_INIT | \
-		HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | \
-		HDMI_IH_CEC_STAT0_DONE | 0x180)) == 0) {
+
+	if ((cec_stat & ~CEC_STAT0_MASK_DEFAULT) == 0) {
+		if (hdmi_cec->cec_state)
+			hdmi_writeb(CEC_STAT0_MASK_DEFAULT, HDMI_IH_MUTE_CEC_STAT0);
 		spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
-		return IRQ_HANDLED;
+		return IRQ_NONE;
 	}
-	pr_debug("HDMI CEC interrupt received\n");
-	/* FIXME : there is a race with latest_cec_stat */
-	hdmi_cec->latest_cec_stat = cec_stat ;
 
-	schedule_delayed_work(&(hdmi_cec->hdmi_cec_work), msecs_to_jiffies(20));
+	pr_debug("HDMI-CEC: interrupt received\n");
+
+	hdmi_cec->cec_stat0 = cec_stat | get_hpd_stat(hdmi_cec);
+	schedule_work(&hdmi_cec->hdmi_cec_work);
 
 	spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
 
 	return IRQ_HANDLED;
 }
 
-void mxc_hdmi_cec_handle(u16 cec_stat)
+static void mxc_hdmi_cec_handle(u32 cec_stat)
 {
 	u8 i = 0;
 	struct hdmi_cec_event *event = NULL;
-	/*The current transmission is successful (for initiator only).*/
+
 	if (!open_count)
 		return;
 
+	/*The current transmission is successful (for initiator only).*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_DONE) {
 		hdmi_cec_data.tx_answer = cec_stat;
 		wake_up(&tx_cec_queue);
 	}
 	/*EOM is detected so that the received data is ready in the receiver data buffer*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_EOM) {
-		hdmi_writeb(0x02, HDMI_IH_CEC_STAT0);
 		event = vmalloc(sizeof(struct hdmi_cec_event));
 		if (NULL == event) {
 			pr_err("%s: Not enough memory!\n", __func__);
@@ -181,8 +208,8 @@ void mxc_hdmi_cec_handle(u16 cec_stat)
 		hdmi_cec_data.receive_error++;
 	}
 	/*HDMI cable connected*/
-	if (cec_stat & 0x80) {
-		pr_info("HDMI link connected\n");
+	if (cec_stat & CEC_STAT0_EX_CONNECTED) {
+		pr_info("HDMI-CEC: link connected\n");
 		event = vmalloc(sizeof(struct hdmi_cec_event));
 		if (NULL == event) {
 			pr_err("%s: Not enough memory\n", __func__);
@@ -196,8 +223,8 @@ void mxc_hdmi_cec_handle(u16 cec_stat)
 		wake_up(&hdmi_cec_queue);
 	}
 	/*HDMI cable disconnected*/
-	if (cec_stat & 0x100) {
-		pr_info("HDMI link disconnected\n");
+	if (cec_stat & CEC_STAT0_EX_DISCONNECTED) {
+		pr_info("HDMI-CEC: link disconnected\n");
 		event = vmalloc(sizeof(struct hdmi_cec_event));
 		if (NULL == event) {
 			pr_err("%s: Not enough memory!\n", __func__);
@@ -210,15 +237,19 @@ void mxc_hdmi_cec_handle(u16 cec_stat)
 		mutex_unlock(&hdmi_cec_data.lock);
 		wake_up(&hdmi_cec_queue);
 	}
-    return;
 }
-EXPORT_SYMBOL(mxc_hdmi_cec_handle);
+
 static void mxc_hdmi_cec_worker(struct work_struct *work)
 {
-	u8 val;
-	mxc_hdmi_cec_handle(hdmi_cec_data.latest_cec_stat);
-	val = HDMI_IH_CEC_STAT0_WAKEUP | HDMI_IH_CEC_STAT0_ERROR_FOLL | HDMI_IH_CEC_STAT0_ARB_LOST;
-	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
+	unsigned long flags;
+
+	mxc_hdmi_cec_handle(hdmi_cec_data.cec_stat0);
+
+	spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
+	hdmi_cec_data.cec_stat0 = 0;
+	if (hdmi_cec_data.cec_state)
+		hdmi_writeb(CEC_STAT0_MASK_DEFAULT, HDMI_IH_MUTE_CEC_STAT0);
+	spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
 }
 
 static int hdmi_cec_open(struct inode *inode, struct file *filp)
@@ -244,7 +275,7 @@ static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 	pr_debug("function : %s\n", __func__);
 
 	mutex_lock(&hdmi_cec_data.lock);
-	if (false == hdmi_cec_data.cec_state) {
+	if (!hdmi_cec_data.cec_state) {
 		mutex_unlock(&hdmi_cec_data.lock);
 		return -EACCES;
 	}
@@ -278,32 +309,31 @@ static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 			     size_t count, loff_t *ppos)
 {
-	int ret = 0 , i = 0;
-	u8 msg[MAX_MESSAGE_LEN];
-	u8 msg_len = 0, val = 0;
+	int ret = 0;
+	u8 i, msg_len, val;
+	u8 msg[MAX_MESSAGE_LEN] = { 0 };
 
 	pr_debug("function : %s\n", __func__);
 
 	mutex_lock(&hdmi_cec_data.lock);
-	if (false == hdmi_cec_data.cec_state) {
-		mutex_unlock(&hdmi_cec_data.lock);
-		return -EACCES;
-	}
-	/* Ensure that there is only one writer who is the unique listener of tx_cec_queue */
-	if (hdmi_cec_data.tx_answer != CEC_TX_AVAIL) {
+
+	if (!hdmi_cec_data.cec_state)
+		ret = -EACCES;
+	else if (hdmi_cec_data.tx_answer != CEC_TX_AVAIL)
+		ret = -EBUSY;
+	else if (count > MAX_MESSAGE_LEN)
+		ret = -EINVAL;
+	else if (copy_from_user(&msg, buf, count))
+		ret = -EACCES;
+
+	if (ret) {
 		mutex_unlock(&hdmi_cec_data.lock);
-		return -EBUSY;
+		return ret;
 	}
-	mutex_unlock(&hdmi_cec_data.lock);
-	if (count > MAX_MESSAGE_LEN)
-		return -EINVAL;
-	memset(&msg, 0, MAX_MESSAGE_LEN);
-	ret = copy_from_user(&msg, buf, count);
-	if (ret)
-		return -EACCES;
-	mutex_lock(&hdmi_cec_data.lock);
+
 	hdmi_cec_data.send_error = 0;
 	hdmi_cec_data.tx_answer = CEC_TX_INPROGRESS;
+
 	msg_len = count;
 	hdmi_writeb(msg_len, HDMI_CEC_TX_CNT);
 	for (i = 0; i < msg_len; i++)
@@ -311,9 +341,11 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	val = hdmi_readb(HDMI_CEC_CTRL);
 	val |= 0x01;
 	hdmi_writeb(val, HDMI_CEC_CTRL);
+
 	mutex_unlock(&hdmi_cec_data.lock);
 
-	ret = wait_event_interruptible_timeout(tx_cec_queue, hdmi_cec_data.tx_answer != CEC_TX_INPROGRESS, HZ);
+	ret = wait_event_interruptible_timeout(
+		tx_cec_queue, hdmi_cec_data.tx_answer != CEC_TX_INPROGRESS, HZ);
 
 	if (ret < 0) {
 		ret = -ERESTARTSYS;
@@ -331,10 +363,37 @@ tx_out:
 	return ret;
 }
 
+void hdmi_cec_hpd_changed(unsigned int state)
+{
+	unsigned long flags;
+	u32           cec_stat0;
+
+	pr_debug("function : %s\n", __func__);
+
+	link_status = state & 1;
+
+	if (is_initialized) {
+		spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
+		cec_stat0 = get_hpd_stat(&hdmi_cec_data);
+		spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
+
+		if (cec_stat0)
+			mxc_hdmi_cec_handle(cec_stat0);
+	}
+}
+EXPORT_SYMBOL(hdmi_cec_hpd_changed);
 
 void hdmi_cec_start_device(void)
 {
 	u8 val;
+	unsigned long flags;
+
+	if (!is_initialized) {
+		want_start = 1;
+		return;
+	}
+
+	spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
 
 	val = hdmi_readb(HDMI_MC_CLKDIS);
 	val &= ~HDMI_MC_CLKDIS_CECCLK_DISABLE;
@@ -342,30 +401,44 @@ void hdmi_cec_start_device(void)
 	hdmi_writeb(0x02, HDMI_CEC_CTRL);
 	/* Force read unlock */
 	hdmi_writeb(0x0, HDMI_CEC_LOCK);
+
 	val = HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
 	hdmi_writeb(val, HDMI_CEC_POLARITY);
-	val = HDMI_IH_CEC_STAT0_WAKEUP | HDMI_IH_CEC_STAT0_ERROR_FOLL | HDMI_IH_CEC_STAT0_ARB_LOST;
+
+	val = CEC_STAT0_MASK_DEFAULT;
 	hdmi_writeb(val, HDMI_CEC_MASK);
 	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
-	hdmi_cec_data.link_status = hdmi_readb(HDMI_PHY_STAT0) & 0x02;
+	hdmi_cec_data.link_status = link_status;
 	hdmi_cec_data.cec_state = true;
+
+	spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
 }
 EXPORT_SYMBOL(hdmi_cec_start_device);
 
 void hdmi_cec_stop_device(void)
 { 
 	u8 val;
+	unsigned long flags;
 
+	if (!is_initialized) {
+		want_start = 0;
+		return;
+	}
+
+	spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
+
+	hdmi_cec_data.cec_state = false;
 	hdmi_writeb(0x10, HDMI_CEC_CTRL);
-	val = HDMI_IH_CEC_STAT0_WAKEUP | HDMI_IH_CEC_STAT0_ERROR_FOLL | HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_ARB_LOST | \
-			HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
+	val = CEC_STAT0_MASK_ALL;
 	hdmi_writeb(val, HDMI_CEC_MASK);
 	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
+
 	hdmi_writeb(0x0, HDMI_CEC_POLARITY);
 	val = hdmi_readb(HDMI_MC_CLKDIS);
 	val |= HDMI_MC_CLKDIS_CECCLK_DISABLE;
 	hdmi_writeb(val, HDMI_MC_CLKDIS);
-	hdmi_cec_data.cec_state = false;
+
+	spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
 }
 EXPORT_SYMBOL(hdmi_cec_stop_device);
 
@@ -381,7 +454,7 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 	switch (cmd) {
 	case HDMICEC_IOC_SETLOGICALADDRESS:
 		mutex_lock(&hdmi_cec_data.lock);
-		if (false == hdmi_cec_data.cec_state) {
+		if (!hdmi_cec_data.cec_state) {
 			mutex_unlock(&hdmi_cec_data.lock);
 			pr_err("Trying to set logical address while not started\n");
 			return -EACCES;
@@ -474,32 +547,23 @@ const struct file_operations hdmi_cec_fops = {
 static int hdmi_cec_dev_probe(struct platform_device *pdev)
 {
 	int err = 0;
-	struct device *temp_class;
-	struct resource *res;
 	struct pinctrl *pinctrl;
-	int irq = platform_get_irq(pdev, 0);
+	struct device *temp_class;
+
+	hdmi_cec_irq = platform_get_irq(pdev, 0);
+	if (hdmi_cec_irq < 0) {
+		dev_err(&pdev->dev, "No HDMI irq line provided\n");
+		err = -ENXIO;
+		goto err_out;
+	}
 
 	hdmi_cec_major = register_chrdev(hdmi_cec_major, "mxc_hdmi_cec", &hdmi_cec_fops);
 	if (hdmi_cec_major < 0) {
 		dev_err(&pdev->dev, "Unable to get a major for HDMI CEC\n");
 		err = -EBUSY;
-		goto out;
+		goto err_out;
 	}
 	
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (unlikely(res == NULL)) {
-		dev_err(&pdev->dev, "No HDMI irq line provided\n");
-		goto err_out_chrdev;
-	}
-	spin_lock_init(&hdmi_cec_data.irq_lock);
-
-	err = devm_request_irq(&pdev->dev, irq, mxc_hdmi_cec_isr, IRQF_SHARED,
-			dev_name(&pdev->dev), &hdmi_cec_data);
-	if (err < 0) {
-		dev_err(&pdev->dev, "Unable to request irq: %d\n", err);
-		goto err_out_chrdev;
-	}
-
 	hdmi_cec_class = class_create(THIS_MODULE, "mxc_hdmi_cec");
 	if (IS_ERR(hdmi_cec_class)) {
 		err = PTR_ERR(hdmi_cec_class);
@@ -507,7 +571,7 @@ static int hdmi_cec_dev_probe(struct platform_device *pdev)
 	}
 
 	temp_class = device_create(hdmi_cec_class, NULL,
-				   MKDEV(hdmi_cec_major, 0), NULL, "mxc_hdmi_cec");
+				MKDEV(hdmi_cec_major, 0), NULL, "mxc_hdmi_cec");
 	if (IS_ERR(temp_class)) {
 		err = PTR_ERR(temp_class);
 		goto err_out_class;
@@ -516,29 +580,44 @@ static int hdmi_cec_dev_probe(struct platform_device *pdev)
 	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
 	if (IS_ERR(pinctrl)) {
 		dev_err(&pdev->dev, "Can't get/select CEC pinctrl\n");
+		err = PTR_ERR(pinctrl);
 		goto err_out_class;
 	}
 
+	INIT_LIST_HEAD(&head);
+
 	init_waitqueue_head(&hdmi_cec_queue);
 	init_waitqueue_head(&tx_cec_queue);
 
-	INIT_LIST_HEAD(&head);
-
 	mutex_init(&hdmi_cec_data.lock);
+	spin_lock_init(&hdmi_cec_data.irq_lock);
+
 	hdmi_cec_data.Logical_address = 15;
 	hdmi_cec_data.tx_answer = CEC_TX_AVAIL;
+	INIT_WORK(&hdmi_cec_data.hdmi_cec_work, mxc_hdmi_cec_worker);
+
 	platform_set_drvdata(pdev, &hdmi_cec_data);
-	INIT_DELAYED_WORK(&hdmi_cec_data.hdmi_cec_work, mxc_hdmi_cec_worker);
 
-	dev_info(&pdev->dev, "HDMI CEC initialized\n");
-	goto out;
+	err = devm_request_irq(&pdev->dev, hdmi_cec_irq, mxc_hdmi_cec_isr,
+				IRQF_SHARED, dev_name(&pdev->dev), &hdmi_cec_data);
+	if (err < 0) {
+		dev_err(&pdev->dev, "Unable to request irq%d: %d\n", hdmi_cec_irq, err);
+		goto err_out_class;
+	}
+
+	is_initialized = 1;
+	if (want_start)
+	      hdmi_cec_start_device();
+
+	pr_info("HDMI-CEC initialized\n");
+	return 0;
 
 err_out_class:
 	device_destroy(hdmi_cec_class, MKDEV(hdmi_cec_major, 0));
 	class_destroy(hdmi_cec_class);
 err_out_chrdev:
 	unregister_chrdev(hdmi_cec_major, "mxc_hdmi_cec");
-out:
+err_out:
 	return err;
 }
 
@@ -546,6 +625,9 @@ static int hdmi_cec_dev_remove(struct platform_device *pdev)
 {
 	hdmi_cec_stop_device();
 
+	is_initialized = 0;
+	devm_free_irq(&pdev->dev, hdmi_cec_irq, &hdmi_cec_data);
+
 	device_destroy(hdmi_cec_class, MKDEV(hdmi_cec_major, 0));
 	class_destroy(hdmi_cec_class);
 	unregister_chrdev(hdmi_cec_major, "mxc_hdmi_cec");
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 55c39e1..591dde4 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -212,7 +212,6 @@ static bool hdmi_inited;
 static bool hdcp_init;
 
 extern const struct fb_videomode mxc_cea_mode[64];
-extern void mxc_hdmi_cec_handle(u16 cec_stat);
 
 extern int mxcfb_blank(int blank, struct fb_info *info);
 
@@ -2204,7 +2203,8 @@ static void hotplug_worker(struct work_struct *work)
 			sprintf(event_string, "EVENT=plugin");
 			kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
 #ifdef CONFIG_MXC_HDMI_CEC
-			mxc_hdmi_cec_handle(0x80);
+			if (hdmi->edid_cfg.hdmi_cap)
+				hdmi_cec_hpd_changed(1);
 #endif
 		} else {
 			/* Plugout event */
@@ -2216,7 +2216,8 @@ static void hotplug_worker(struct work_struct *work)
 			sprintf(event_string, "EVENT=plugout");
 			kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
 #ifdef CONFIG_MXC_HDMI_CEC
-			mxc_hdmi_cec_handle(0x100);
+			if (hdmi->edid_cfg.hdmi_cap)
+				hdmi_cec_hpd_changed(0);
 #endif
 		}
 	}
diff --git a/include/linux/mfd/mxc-hdmi-core.h b/include/linux/mfd/mxc-hdmi-core.h
index db16f5f..6c9c36d 100644
--- a/include/linux/mfd/mxc-hdmi-core.h
+++ b/include/linux/mfd/mxc-hdmi-core.h
@@ -64,5 +64,6 @@ int check_hdmi_state(void);
 
 void hdmi_cec_start_device(void);
 void hdmi_cec_stop_device(void);
+void hdmi_cec_hpd_changed(unsigned int state);
 
 #endif
-- 
1.9.1


==============================================================
file 0006-MXC-CEC-Rename-variables-minor-code-style-cleanups.patch
==============================================================

From 07f57cc3eea59941d627fb46c95776ce67309e5f Mon Sep 17 00:00:00 2001
From: warped-rudi <r.ihle@s-t.de>
Date: Wed, 9 Nov 2016 09:27:38 +0100
Subject: [PATCH] MXC-CEC: Rename variables, minor code style cleanups

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 112 ++++++++++++++++++------------------
 1 file changed, 56 insertions(+), 56 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index f62bcbc..b0619ac 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -75,13 +75,14 @@
 				 HDMI_IH_CEC_STAT0_ARB_LOST)
 
 struct hdmi_cec_priv {
-	int  receive_error;
-	int  send_error;
-	u8 Logical_address;
-	u8 cec_state;
+	int receive_error;
+	int send_error;
 	int tx_answer;
 	u32 cec_stat0;
+	u8 logical_address;
+	u8 is_started;
 	u8 link_status;
+	u8 open_count;
 	spinlock_t irq_lock;
 	struct work_struct hdmi_cec_work;
 	struct mutex lock;
@@ -95,19 +96,18 @@ struct hdmi_cec_event {
 };
 
 
-static LIST_HEAD(head);
+static LIST_HEAD(ev_pending);
 
 static int hdmi_cec_irq;
 static int hdmi_cec_major;
 static struct class *hdmi_cec_class;
 static struct hdmi_cec_priv hdmi_cec_data;
-static u8 open_count;
 static u8 want_start;
 static u8 link_status;
 static u8 is_initialized;
 
-static wait_queue_head_t hdmi_cec_queue;
-static wait_queue_head_t tx_cec_queue;
+static wait_queue_head_t rx_queue;
+static wait_queue_head_t tx_queue;
 
 
 static u32 get_hpd_stat(struct hdmi_cec_priv *hdmi_cec)
@@ -139,7 +139,7 @@ static irqreturn_t mxc_hdmi_cec_isr(int irq, void *data)
 	hdmi_writeb(cec_stat, HDMI_IH_CEC_STAT0);
 
 	if ((cec_stat & ~CEC_STAT0_MASK_DEFAULT) == 0) {
-		if (hdmi_cec->cec_state)
+		if (hdmi_cec->is_started)
 			hdmi_writeb(CEC_STAT0_MASK_DEFAULT, HDMI_IH_MUTE_CEC_STAT0);
 		spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
 		return IRQ_NONE;
@@ -160,13 +160,13 @@ static void mxc_hdmi_cec_handle(u32 cec_stat)
 	u8 i = 0;
 	struct hdmi_cec_event *event = NULL;
 
-	if (!open_count)
+	if (!hdmi_cec_data.open_count)
 		return;
 
 	/*The current transmission is successful (for initiator only).*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_DONE) {
 		hdmi_cec_data.tx_answer = cec_stat;
-		wake_up(&tx_cec_queue);
+		wake_up(&tx_queue);
 	}
 	/*EOM is detected so that the received data is ready in the receiver data buffer*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_EOM) {
@@ -186,14 +186,14 @@ static void mxc_hdmi_cec_handle(u32 cec_stat)
 			event->msg[i] = hdmi_readb(HDMI_CEC_RX_DATA0+i);
 		hdmi_writeb(0x0, HDMI_CEC_LOCK);
 		mutex_lock(&hdmi_cec_data.lock);
-		list_add_tail(&event->list, &head);
+		list_add_tail(&event->list, &ev_pending);
 		mutex_unlock(&hdmi_cec_data.lock);
-		wake_up(&hdmi_cec_queue);
+		wake_up(&rx_queue);
 	}
 	/*An error is detected on cec line (for initiator only). */
 	if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_INIT) {
 		hdmi_cec_data.tx_answer = cec_stat;
-		wake_up(&tx_cec_queue);
+		wake_up(&tx_queue);
 		return;
 	}
 	/*A frame is not acknowledged in a directly addressed message. Or a frame is negatively acknowledged in
@@ -201,7 +201,7 @@ static void mxc_hdmi_cec_handle(u32 cec_stat)
 	if (cec_stat & HDMI_IH_CEC_STAT0_NACK) {
 		hdmi_cec_data.send_error++;
 		hdmi_cec_data.tx_answer = cec_stat;
-		wake_up(&tx_cec_queue);
+		wake_up(&tx_queue);
 	}
 	/*An error is notified by a follower. Abnormal logic data bit error (for follower).*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_FOLL) {
@@ -218,9 +218,9 @@ static void mxc_hdmi_cec_handle(u32 cec_stat)
 		memset(event, 0, sizeof(struct hdmi_cec_event));
 		event->event_type = MESSAGE_TYPE_CONNECTED;
 		mutex_lock(&hdmi_cec_data.lock);
-		list_add_tail(&event->list, &head);
+		list_add_tail(&event->list, &ev_pending);
 		mutex_unlock(&hdmi_cec_data.lock);
-		wake_up(&hdmi_cec_queue);
+		wake_up(&rx_queue);
 	}
 	/*HDMI cable disconnected*/
 	if (cec_stat & CEC_STAT0_EX_DISCONNECTED) {
@@ -233,9 +233,9 @@ static void mxc_hdmi_cec_handle(u32 cec_stat)
 		memset(event, 0, sizeof(struct hdmi_cec_event));
 		event->event_type = MESSAGE_TYPE_DISCONNECTED;
 		mutex_lock(&hdmi_cec_data.lock);
-		list_add_tail(&event->list, &head);
+		list_add_tail(&event->list, &ev_pending);
 		mutex_unlock(&hdmi_cec_data.lock);
-		wake_up(&hdmi_cec_queue);
+		wake_up(&rx_queue);
 	}
 }
 
@@ -247,22 +247,22 @@ static void mxc_hdmi_cec_worker(struct work_struct *work)
 
 	spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
 	hdmi_cec_data.cec_stat0 = 0;
-	if (hdmi_cec_data.cec_state)
+	if (hdmi_cec_data.is_started)
 		hdmi_writeb(CEC_STAT0_MASK_DEFAULT, HDMI_IH_MUTE_CEC_STAT0);
 	spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
 }
 
-static int hdmi_cec_open(struct inode *inode, struct file *filp)
+static int hdmi_cec_open(struct inode *inode, struct file *file)
 {
 	mutex_lock(&hdmi_cec_data.lock);
-	if (open_count) {
+	if (hdmi_cec_data.open_count) {
 		mutex_unlock(&hdmi_cec_data.lock);
 		return -EBUSY;
 	}
-	open_count = 1;
-	filp->private_data = (void *)(&hdmi_cec_data);
-	hdmi_cec_data.Logical_address = 15;
-	hdmi_cec_data.cec_state = false;
+	hdmi_cec_data.open_count = 1;
+	file->private_data = (void *)(&hdmi_cec_data);
+	hdmi_cec_data.logical_address = 15;
+	hdmi_cec_data.is_started = false;
 	mutex_unlock(&hdmi_cec_data.lock);
 	return 0;
 }
@@ -275,26 +275,26 @@ static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 	pr_debug("function : %s\n", __func__);
 
 	mutex_lock(&hdmi_cec_data.lock);
-	if (!hdmi_cec_data.cec_state) {
+	if (!hdmi_cec_data.is_started) {
 		mutex_unlock(&hdmi_cec_data.lock);
 		return -EACCES;
 	}
 
-	if (list_empty(&head)) {
+	if (list_empty(&ev_pending)) {
 		if (file->f_flags & O_NONBLOCK) {
 			mutex_unlock(&hdmi_cec_data.lock);
 			return -EAGAIN;
 		} else {
 			do {
 				mutex_unlock(&hdmi_cec_data.lock);
-				if (wait_event_interruptible(hdmi_cec_queue, (!list_empty(&head))))
+				if (wait_event_interruptible(rx_queue, !list_empty(&ev_pending)))
 					return -ERESTARTSYS;
 				mutex_lock(&hdmi_cec_data.lock);
-			} while (list_empty(&head));
+			} while (list_empty(&ev_pending));
 		}
 	}
 
-	event = list_first_entry(&head, struct hdmi_cec_event, list);
+	event = list_first_entry(&ev_pending, struct hdmi_cec_event, list);
 	list_del(&event->list);
 	mutex_unlock(&hdmi_cec_data.lock);
 	if (copy_to_user(buf, event,
@@ -311,19 +311,19 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 {
 	int ret = 0;
 	u8 i, msg_len, val;
-	u8 msg[MAX_MESSAGE_LEN] = { 0 };
+	u8 msg[MAX_MESSAGE_LEN];
 
 	pr_debug("function : %s\n", __func__);
 
 	mutex_lock(&hdmi_cec_data.lock);
 
-	if (!hdmi_cec_data.cec_state)
+	if (!hdmi_cec_data.is_started)
 		ret = -EACCES;
 	else if (hdmi_cec_data.tx_answer != CEC_TX_AVAIL)
 		ret = -EBUSY;
 	else if (count > MAX_MESSAGE_LEN)
 		ret = -EINVAL;
-	else if (copy_from_user(&msg, buf, count))
+	else if (copy_from_user(msg, buf, count))
 		ret = -EACCES;
 
 	if (ret) {
@@ -345,7 +345,7 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	mutex_unlock(&hdmi_cec_data.lock);
 
 	ret = wait_event_interruptible_timeout(
-		tx_cec_queue, hdmi_cec_data.tx_answer != CEC_TX_INPROGRESS, HZ);
+		tx_queue, hdmi_cec_data.tx_answer != CEC_TX_INPROGRESS, HZ);
 
 	if (ret < 0) {
 		ret = -ERESTARTSYS;
@@ -409,7 +409,7 @@ void hdmi_cec_start_device(void)
 	hdmi_writeb(val, HDMI_CEC_MASK);
 	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
 	hdmi_cec_data.link_status = link_status;
-	hdmi_cec_data.cec_state = true;
+	hdmi_cec_data.is_started = true;
 
 	spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
 }
@@ -427,7 +427,7 @@ void hdmi_cec_stop_device(void)
 
 	spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
 
-	hdmi_cec_data.cec_state = false;
+	hdmi_cec_data.is_started = false;
 	hdmi_writeb(0x10, HDMI_CEC_CTRL);
 	val = CEC_STAT0_MASK_ALL;
 	hdmi_writeb(val, HDMI_CEC_MASK);
@@ -442,7 +442,7 @@ void hdmi_cec_stop_device(void)
 }
 EXPORT_SYMBOL(hdmi_cec_stop_device);
 
-static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
+static long hdmi_cec_ioctl(struct file *file, u_int cmd,
 		     u_long arg)
 {
 	int ret = 0, status = 0;
@@ -454,18 +454,18 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 	switch (cmd) {
 	case HDMICEC_IOC_SETLOGICALADDRESS:
 		mutex_lock(&hdmi_cec_data.lock);
-		if (!hdmi_cec_data.cec_state) {
+		if (!hdmi_cec_data.is_started) {
 			mutex_unlock(&hdmi_cec_data.lock);
 			pr_err("Trying to set logical address while not started\n");
 			return -EACCES;
 		}
-		hdmi_cec_data.Logical_address = (u8)arg;
-		if (hdmi_cec_data.Logical_address <= 7) {
-			val = 1 << hdmi_cec_data.Logical_address;
+		hdmi_cec_data.logical_address = (u8)arg;
+		if (hdmi_cec_data.logical_address <= 7) {
+			val = 1 << hdmi_cec_data.logical_address;
 			hdmi_writeb(val, HDMI_CEC_ADDR_L);
 			hdmi_writeb(0, HDMI_CEC_ADDR_H);
-		} else if (hdmi_cec_data.Logical_address > 7 && hdmi_cec_data.Logical_address <= 15) {
-			val = 1 << (hdmi_cec_data.Logical_address - 8);
+		} else if (hdmi_cec_data.logical_address > 7 && hdmi_cec_data.logical_address <= 15) {
+			val = 1 << (hdmi_cec_data.logical_address - 8);
 			hdmi_writeb(val, HDMI_CEC_ADDR_H);
 			hdmi_writeb(0, HDMI_CEC_ADDR_L);
 		} else
@@ -493,20 +493,20 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
     return ret;
 }
 
-static int hdmi_cec_release(struct inode *inode, struct file *filp)
+static int hdmi_cec_release(struct inode *inode, struct file *file)
 {
 	struct hdmi_cec_event *event, *tmp_event;
 
 	pr_debug("function : %s\n", __func__);
 
 	mutex_lock(&hdmi_cec_data.lock);
-	if (open_count) {
-		open_count = 0;
-		hdmi_cec_data.cec_state = false;
-		hdmi_cec_data.Logical_address = 15;
+	if (hdmi_cec_data.open_count) {
+		hdmi_cec_data.open_count = 0;
+		hdmi_cec_data.is_started = false;
+		hdmi_cec_data.logical_address = 15;
 
 		/* Flush eventual events which have not been read by user space */
-		list_for_each_entry_safe(event, tmp_event, &head, list) {
+		list_for_each_entry_safe(event, tmp_event, &ev_pending, list) {
 			list_del(&event->list);
 			vfree(event);
 		}
@@ -522,12 +522,12 @@ static unsigned int hdmi_cec_poll(struct file *file, poll_table *wait)
 
 	pr_debug("function : %s\n", __func__);
 
-	poll_wait(file, &hdmi_cec_queue, wait);
+	poll_wait(file, &rx_queue, wait);
 
 	/* Always writable */
 	mask =  (POLLOUT | POLLWRNORM);
 	mutex_lock(&hdmi_cec_data.lock);
-	if (!list_empty(&head))
+	if (!list_empty(&ev_pending))
 		mask |= (POLLIN | POLLRDNORM);
 	mutex_unlock(&hdmi_cec_data.lock);
 	return mask;
@@ -584,15 +584,15 @@ static int hdmi_cec_dev_probe(struct platform_device *pdev)
 		goto err_out_class;
 	}
 
-	INIT_LIST_HEAD(&head);
+	INIT_LIST_HEAD(&ev_pending);
 
-	init_waitqueue_head(&hdmi_cec_queue);
-	init_waitqueue_head(&tx_cec_queue);
+	init_waitqueue_head(&rx_queue);
+	init_waitqueue_head(&tx_queue);
 
 	mutex_init(&hdmi_cec_data.lock);
 	spin_lock_init(&hdmi_cec_data.irq_lock);
 
-	hdmi_cec_data.Logical_address = 15;
+	hdmi_cec_data.logical_address = 15;
 	hdmi_cec_data.tx_answer = CEC_TX_AVAIL;
 	INIT_WORK(&hdmi_cec_data.hdmi_cec_work, mxc_hdmi_cec_worker);
 
-- 
1.9.1


==============================================================
file 0007-MXC-CEC-Use-a-more-efficient-buffer-allocation-schem.patch
==============================================================

From 0205ed2cfff7bbeb8ecd9a17cd068309468aa323 Mon Sep 17 00:00:00 2001
From: warped-rudi <r.ihle@s-t.de>
Date: Wed, 9 Nov 2016 09:27:38 +0100
Subject: [PATCH] MXC-CEC: Use a more efficient buffer allocation scheme

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 170 ++++++++++++++++++++++++------------
 1 file changed, 115 insertions(+), 55 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index b0619ac..22447cf 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -96,6 +96,7 @@ struct hdmi_cec_event {
 };
 
 
+static LIST_HEAD(ev_idle);
 static LIST_HEAD(ev_pending);
 
 static int hdmi_cec_irq;
@@ -110,6 +111,60 @@ static wait_queue_head_t rx_queue;
 static wait_queue_head_t tx_queue;
 
 
+static struct hdmi_cec_event *alloc_event(void)
+{
+	int i;
+	struct hdmi_cec_event *event;
+
+	if (list_empty(&ev_idle)) {
+		event = (void *)__get_free_page(GFP_KERNEL);
+
+		if (!event) {
+			pr_err("HDMI-CEC: Failed to allocate event buffer\n");
+			return NULL;
+		}
+
+		for (i = 1; i < PAGE_SIZE / sizeof(struct hdmi_cec_event); i++)
+		      list_add_tail(&event[i].list, &ev_idle);
+
+		pr_debug("HDMI-CEC: Allocated event buffer page: @%08lx (%d)\n",
+			 (unsigned long)event, i);
+	} else {
+		event = list_first_entry(&ev_idle, struct hdmi_cec_event, list);
+		list_del(&event->list);
+	}
+
+	memset(event, 0, sizeof(struct hdmi_cec_event));
+	return event;
+}
+
+static void free_events(void)
+{
+	struct hdmi_cec_event *event, *tmp_event;
+
+	/* Flush events which have not been read by user space */
+	list_splice_init(&ev_pending, &ev_idle);
+
+	/* Find item(s) starting on a page boundary */
+	list_for_each_entry_safe(event, tmp_event, &ev_idle, list) {
+		if (((unsigned long)event & ~PAGE_MASK) == 0)
+			list_move_tail(&event->list, &ev_pending);
+	}
+
+	/* Discard idle list */
+	INIT_LIST_HEAD(&ev_idle);
+
+	/* Empty pending list and free page(s) */
+	while (!list_empty(&ev_pending)) {
+		event = list_first_entry(&ev_pending, struct hdmi_cec_event, list);
+		list_del(&event->list);
+		free_page((unsigned long)event);
+
+		pr_debug("HDMI-CEC: Freed event buffer page: @%08lx\n",
+			 (unsigned long)event);
+	}
+}
+
 static u32 get_hpd_stat(struct hdmi_cec_priv *hdmi_cec)
 {
 	u32 cec_stat0 = 0;
@@ -157,12 +212,29 @@ static irqreturn_t mxc_hdmi_cec_isr(int irq, void *data)
 
 static void mxc_hdmi_cec_handle(u32 cec_stat)
 {
-	u8 i = 0;
-	struct hdmi_cec_event *event = NULL;
+	int i;
+	struct hdmi_cec_event *event;
 
 	if (!hdmi_cec_data.open_count)
 		return;
 
+	/*HDMI cable connected: handle first*/
+	if (cec_stat & CEC_STAT0_EX_CONNECTED) {
+		pr_info("HDMI-CEC: link connected\n");
+
+		mutex_lock(&hdmi_cec_data.lock);
+		event = alloc_event();
+		if (!event) {
+			mutex_unlock(&hdmi_cec_data.lock);
+			return;
+		}
+		event->event_type = MESSAGE_TYPE_CONNECTED;
+		list_add_tail(&event->list, &ev_pending);
+		mutex_unlock(&hdmi_cec_data.lock);
+
+		wake_up(&rx_queue);
+	}
+
 	/*The current transmission is successful (for initiator only).*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_DONE) {
 		hdmi_cec_data.tx_answer = cec_stat;
@@ -170,24 +242,28 @@ static void mxc_hdmi_cec_handle(u32 cec_stat)
 	}
 	/*EOM is detected so that the received data is ready in the receiver data buffer*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_EOM) {
-		event = vmalloc(sizeof(struct hdmi_cec_event));
-		if (NULL == event) {
-			pr_err("%s: Not enough memory!\n", __func__);
+		mutex_lock(&hdmi_cec_data.lock);
+		event = alloc_event();
+		if (!event) {
+			mutex_unlock(&hdmi_cec_data.lock);
 			return;
 		}
-		memset(event, 0, sizeof(struct hdmi_cec_event));
+
 		event->msg_len = hdmi_readb(HDMI_CEC_RX_CNT);
-		if (!event->msg_len) {
-			pr_err("%s: Invalid CEC message length!\n", __func__);
+		if (!event->msg_len || event->msg_len > MAX_MESSAGE_LEN) {
+			pr_err("HDMI-CEC: Invalid CEC message length\n");
+			list_add_tail(&event->list, &ev_idle);
+			mutex_unlock(&hdmi_cec_data.lock);
 			return;
 		}
+
 		event->event_type = MESSAGE_TYPE_RECEIVE_SUCCESS;
 		for (i = 0; i < event->msg_len; i++)
-			event->msg[i] = hdmi_readb(HDMI_CEC_RX_DATA0+i);
-		hdmi_writeb(0x0, HDMI_CEC_LOCK);
-		mutex_lock(&hdmi_cec_data.lock);
+			event->msg[i] = hdmi_readb(HDMI_CEC_RX_DATA0 + i);
+
 		list_add_tail(&event->list, &ev_pending);
 		mutex_unlock(&hdmi_cec_data.lock);
+
 		wake_up(&rx_queue);
 	}
 	/*An error is detected on cec line (for initiator only). */
@@ -207,34 +283,21 @@ static void mxc_hdmi_cec_handle(u32 cec_stat)
 	if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_FOLL) {
 		hdmi_cec_data.receive_error++;
 	}
-	/*HDMI cable connected*/
-	if (cec_stat & CEC_STAT0_EX_CONNECTED) {
-		pr_info("HDMI-CEC: link connected\n");
-		event = vmalloc(sizeof(struct hdmi_cec_event));
-		if (NULL == event) {
-			pr_err("%s: Not enough memory\n", __func__);
-			return;
-		}
-		memset(event, 0, sizeof(struct hdmi_cec_event));
-		event->event_type = MESSAGE_TYPE_CONNECTED;
-		mutex_lock(&hdmi_cec_data.lock);
-		list_add_tail(&event->list, &ev_pending);
-		mutex_unlock(&hdmi_cec_data.lock);
-		wake_up(&rx_queue);
-	}
-	/*HDMI cable disconnected*/
+
+	/*HDMI cable disconnected: handle last*/
 	if (cec_stat & CEC_STAT0_EX_DISCONNECTED) {
 		pr_info("HDMI-CEC: link disconnected\n");
-		event = vmalloc(sizeof(struct hdmi_cec_event));
-		if (NULL == event) {
-			pr_err("%s: Not enough memory!\n", __func__);
+
+		mutex_lock(&hdmi_cec_data.lock);
+		event = alloc_event();
+		if (!event) {
+			mutex_unlock(&hdmi_cec_data.lock);
 			return;
 		}
-		memset(event, 0, sizeof(struct hdmi_cec_event));
 		event->event_type = MESSAGE_TYPE_DISCONNECTED;
-		mutex_lock(&hdmi_cec_data.lock);
 		list_add_tail(&event->list, &ev_pending);
 		mutex_unlock(&hdmi_cec_data.lock);
+
 		wake_up(&rx_queue);
 	}
 }
@@ -245,6 +308,9 @@ static void mxc_hdmi_cec_worker(struct work_struct *work)
 
 	mxc_hdmi_cec_handle(hdmi_cec_data.cec_stat0);
 
+	if (hdmi_cec_data.cec_stat0 & HDMI_IH_CEC_STAT0_EOM)
+		hdmi_writeb(0x0, HDMI_CEC_LOCK);
+
 	spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
 	hdmi_cec_data.cec_stat0 = 0;
 	if (hdmi_cec_data.is_started)
@@ -270,7 +336,8 @@ static int hdmi_cec_open(struct inode *inode, struct file *file)
 static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 			    loff_t *ppos)
 {
-	struct hdmi_cec_event *event = NULL;
+	ssize_t len;
+	struct hdmi_cec_event *event;
 
 	pr_debug("function : %s\n", __func__);
 
@@ -284,26 +351,24 @@ static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 		if (file->f_flags & O_NONBLOCK) {
 			mutex_unlock(&hdmi_cec_data.lock);
 			return -EAGAIN;
-		} else {
-			do {
-				mutex_unlock(&hdmi_cec_data.lock);
-				if (wait_event_interruptible(rx_queue, !list_empty(&ev_pending)))
-					return -ERESTARTSYS;
-				mutex_lock(&hdmi_cec_data.lock);
-			} while (list_empty(&ev_pending));
 		}
+
+		do {
+			mutex_unlock(&hdmi_cec_data.lock);
+			if (wait_event_interruptible(rx_queue, !list_empty(&ev_pending)))
+				return -ERESTARTSYS;
+			mutex_lock(&hdmi_cec_data.lock);
+		} while (list_empty(&ev_pending));
 	}
 
+	len = offsetof(struct hdmi_cec_event, list);
 	event = list_first_entry(&ev_pending, struct hdmi_cec_event, list);
-	list_del(&event->list);
+	if (copy_to_user(buf, event, len))
+		len = -EFAULT;
+	list_move_tail(&event->list, &ev_idle);
 	mutex_unlock(&hdmi_cec_data.lock);
-	if (copy_to_user(buf, event,
-			 sizeof(struct hdmi_cec_event) - sizeof(struct list_head))) {
-		vfree(event);
-		return -EFAULT;
-	}
-	vfree(event);
-	return (sizeof(struct hdmi_cec_event) - sizeof(struct list_head));
+
+	return len;
 }
 
 static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
@@ -495,8 +560,6 @@ static long hdmi_cec_ioctl(struct file *file, u_int cmd,
 
 static int hdmi_cec_release(struct inode *inode, struct file *file)
 {
-	struct hdmi_cec_event *event, *tmp_event;
-
 	pr_debug("function : %s\n", __func__);
 
 	mutex_lock(&hdmi_cec_data.lock);
@@ -505,11 +568,7 @@ static int hdmi_cec_release(struct inode *inode, struct file *file)
 		hdmi_cec_data.is_started = false;
 		hdmi_cec_data.logical_address = 15;
 
-		/* Flush eventual events which have not been read by user space */
-		list_for_each_entry_safe(event, tmp_event, &ev_pending, list) {
-			list_del(&event->list);
-			vfree(event);
-		}
+		free_events();
 	}
 	mutex_unlock(&hdmi_cec_data.lock);
 
@@ -584,6 +643,7 @@ static int hdmi_cec_dev_probe(struct platform_device *pdev)
 		goto err_out_class;
 	}
 
+	INIT_LIST_HEAD(&ev_idle);
 	INIT_LIST_HEAD(&ev_pending);
 
 	init_waitqueue_head(&rx_queue);
-- 
1.9.1


==============================================================
file 0008-MXC-CEC-Fix-message-length-while-keeping-compatibili.patch
==============================================================

From 19dd5ab55ca121073d35d104a49431b8c3cf3cf1 Mon Sep 17 00:00:00 2001
From: warped-rudi <r.ihle@s-t.de>
Date: Wed, 9 Nov 2016 09:27:38 +0100
Subject: [PATCH] MXC-CEC: Fix message length while keeping compatibility with
 old client libs

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index 22447cf..8777320 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -47,7 +47,7 @@
 #include "mxc_hdmi-cec.h"
 
 
-#define MAX_MESSAGE_LEN			17
+#define MAX_MESSAGE_LEN			16
 
 #define MESSAGE_TYPE_RECEIVE_SUCCESS	1
 #define MESSAGE_TYPE_NOACK		2
@@ -92,6 +92,7 @@ struct hdmi_cec_event {
 	int event_type;
 	int msg_len;
 	u8 msg[MAX_MESSAGE_LEN];
+	u8 padding[4];		/* compatibility with old userland */
 	struct list_head list;
 };
 
@@ -336,15 +337,21 @@ static int hdmi_cec_open(struct inode *inode, struct file *file)
 static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 			    loff_t *ppos)
 {
-	ssize_t len;
+	ssize_t len = 0;
 	struct hdmi_cec_event *event;
 
 	pr_debug("function : %s\n", __func__);
 
 	mutex_lock(&hdmi_cec_data.lock);
-	if (!hdmi_cec_data.is_started) {
+
+	if (!hdmi_cec_data.is_started)
+		len = -EACCES;
+	else if (count < offsetof(struct hdmi_cec_event, padding))
+		len = -EINVAL;
+
+	if (len < 0) {
 		mutex_unlock(&hdmi_cec_data.lock);
-		return -EACCES;
+		return len;
 	}
 
 	if (list_empty(&ev_pending)) {
@@ -361,7 +368,8 @@ static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 		} while (list_empty(&ev_pending));
 	}
 
-	len = offsetof(struct hdmi_cec_event, list);
+	/* Hack: older versions of libcec attempt to read more bytes than we provide */
+	len = min(count, offsetof(struct hdmi_cec_event, list));
 	event = list_first_entry(&ev_pending, struct hdmi_cec_event, list);
 	if (copy_to_user(buf, event, len))
 		len = -EFAULT;
-- 
1.9.1


==============================================================
file 0009-MXC-CEC-Change-return-codes-and-add-poll-support-for.patch
==============================================================

From 57a5e256cca14fdf8f4dabd839bf21762cff2eaa Mon Sep 17 00:00:00 2001
From: warped-rudi <r.ihle@s-t.de>
Date: Wed, 9 Nov 2016 09:27:39 +0100
Subject: [PATCH] MXC-CEC: Change return codes and add poll support for write
 function

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 31 ++++++++++++++++++-------------
 1 file changed, 18 insertions(+), 13 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index 8777320..8134cc8 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -328,6 +328,7 @@ static int hdmi_cec_open(struct inode *inode, struct file *file)
 	}
 	hdmi_cec_data.open_count = 1;
 	file->private_data = (void *)(&hdmi_cec_data);
+	hdmi_cec_data.tx_answer = CEC_TX_AVAIL;
 	hdmi_cec_data.logical_address = 15;
 	hdmi_cec_data.is_started = false;
 	mutex_unlock(&hdmi_cec_data.lock);
@@ -393,7 +394,9 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	if (!hdmi_cec_data.is_started)
 		ret = -EACCES;
 	else if (hdmi_cec_data.tx_answer != CEC_TX_AVAIL)
-		ret = -EBUSY;
+		ret = -EAGAIN;
+	else if (hdmi_cec_data.link_status != 1)
+		ret = -EAGAIN;
 	else if (count > MAX_MESSAGE_LEN)
 		ret = -EINVAL;
 	else if (copy_from_user(msg, buf, count))
@@ -420,18 +423,15 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	ret = wait_event_interruptible_timeout(
 		tx_queue, hdmi_cec_data.tx_answer != CEC_TX_INPROGRESS, HZ);
 
-	if (ret < 0) {
+	if (ret < 0)
 		ret = -ERESTARTSYS;
-		goto tx_out;
-	}
-
-	if (hdmi_cec_data.tx_answer & HDMI_IH_CEC_STAT0_DONE)
-		/* msg correctly sent */
-		ret = msg_len;
+	else if (hdmi_cec_data.tx_answer & HDMI_IH_CEC_STAT0_DONE)
+		ret = msg_len;	/* msg sent, ACK received */
+	else if (hdmi_cec_data.tx_answer & HDMI_IH_CEC_STAT0_NACK)
+		ret = -EIO;	/* msg sent, NACK received */
 	else
-		ret = -EIO;
+		ret = -EPIPE;	/* other error */
 
-tx_out:
 	hdmi_cec_data.tx_answer = CEC_TX_AVAIL;
 	return ret;
 }
@@ -575,6 +575,7 @@ static int hdmi_cec_release(struct inode *inode, struct file *file)
 		hdmi_cec_data.open_count = 0;
 		hdmi_cec_data.is_started = false;
 		hdmi_cec_data.logical_address = 15;
+		hdmi_cec_data.tx_answer = CEC_TX_AVAIL;
 
 		free_events();
 	}
@@ -590,13 +591,17 @@ static unsigned int hdmi_cec_poll(struct file *file, poll_table *wait)
 	pr_debug("function : %s\n", __func__);
 
 	poll_wait(file, &rx_queue, wait);
+	poll_wait(file, &tx_queue, wait);
+
+	if (hdmi_cec_data.link_status == 1 &&
+	    hdmi_cec_data.tx_answer == CEC_TX_AVAIL)
+		mask |= POLLOUT | POLLWRNORM;
 
-	/* Always writable */
-	mask =  (POLLOUT | POLLWRNORM);
 	mutex_lock(&hdmi_cec_data.lock);
 	if (!list_empty(&ev_pending))
-		mask |= (POLLIN | POLLRDNORM);
+		mask |= POLLIN | POLLRDNORM;
 	mutex_unlock(&hdmi_cec_data.lock);
+
 	return mask;
 }
 
-- 
1.9.1


==============================================================
file 0010-MXC-CEC-Use-instance-data-pointer-whenever-possible.patch
==============================================================

From 8f0d740e104758b558d8209d4736e7fcf0238b8e Mon Sep 17 00:00:00 2001
From: warped-rudi <r.ihle@s-t.de>
Date: Wed, 9 Nov 2016 09:27:39 +0100
Subject: [PATCH] MXC-CEC: Use instance data pointer whenever possible

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 191 +++++++++++++++++++-----------------
 1 file changed, 100 insertions(+), 91 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index 8134cc8..80344d9 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -183,11 +183,11 @@ static u32 get_hpd_stat(struct hdmi_cec_priv *hdmi_cec)
 
 static irqreturn_t mxc_hdmi_cec_isr(int irq, void *data)
 {
-	struct hdmi_cec_priv *hdmi_cec = data;
+	struct hdmi_cec_priv *priv = data;
 	unsigned long flags;
 	u8 cec_stat;
 
-	spin_lock_irqsave(&hdmi_cec->irq_lock, flags);
+	spin_lock_irqsave(&priv->irq_lock, flags);
 
 	hdmi_writeb(CEC_STAT0_MASK_ALL, HDMI_IH_MUTE_CEC_STAT0);
 
@@ -195,58 +195,58 @@ static irqreturn_t mxc_hdmi_cec_isr(int irq, void *data)
 	hdmi_writeb(cec_stat, HDMI_IH_CEC_STAT0);
 
 	if ((cec_stat & ~CEC_STAT0_MASK_DEFAULT) == 0) {
-		if (hdmi_cec->is_started)
+		if (priv->is_started)
 			hdmi_writeb(CEC_STAT0_MASK_DEFAULT, HDMI_IH_MUTE_CEC_STAT0);
-		spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
+		spin_unlock_irqrestore(&priv->irq_lock, flags);
 		return IRQ_NONE;
 	}
 
 	pr_debug("HDMI-CEC: interrupt received\n");
 
-	hdmi_cec->cec_stat0 = cec_stat | get_hpd_stat(hdmi_cec);
-	schedule_work(&hdmi_cec->hdmi_cec_work);
+	priv->cec_stat0 = cec_stat | get_hpd_stat(priv);
+	schedule_work(&priv->hdmi_cec_work);
 
-	spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
+	spin_unlock_irqrestore(&priv->irq_lock, flags);
 
 	return IRQ_HANDLED;
 }
 
-static void mxc_hdmi_cec_handle(u32 cec_stat)
+static void mxc_hdmi_cec_handle(struct hdmi_cec_priv *priv, u32 cec_stat)
 {
 	int i;
 	struct hdmi_cec_event *event;
 
-	if (!hdmi_cec_data.open_count)
+	if (!priv->open_count)
 		return;
 
 	/*HDMI cable connected: handle first*/
 	if (cec_stat & CEC_STAT0_EX_CONNECTED) {
 		pr_info("HDMI-CEC: link connected\n");
 
-		mutex_lock(&hdmi_cec_data.lock);
+		mutex_lock(&priv->lock);
 		event = alloc_event();
 		if (!event) {
-			mutex_unlock(&hdmi_cec_data.lock);
+			mutex_unlock(&priv->lock);
 			return;
 		}
 		event->event_type = MESSAGE_TYPE_CONNECTED;
 		list_add_tail(&event->list, &ev_pending);
-		mutex_unlock(&hdmi_cec_data.lock);
+		mutex_unlock(&priv->lock);
 
 		wake_up(&rx_queue);
 	}
 
 	/*The current transmission is successful (for initiator only).*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_DONE) {
-		hdmi_cec_data.tx_answer = cec_stat;
+		priv->tx_answer = cec_stat;
 		wake_up(&tx_queue);
 	}
 	/*EOM is detected so that the received data is ready in the receiver data buffer*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_EOM) {
-		mutex_lock(&hdmi_cec_data.lock);
+		mutex_lock(&priv->lock);
 		event = alloc_event();
 		if (!event) {
-			mutex_unlock(&hdmi_cec_data.lock);
+			mutex_unlock(&priv->lock);
 			return;
 		}
 
@@ -254,7 +254,7 @@ static void mxc_hdmi_cec_handle(u32 cec_stat)
 		if (!event->msg_len || event->msg_len > MAX_MESSAGE_LEN) {
 			pr_err("HDMI-CEC: Invalid CEC message length\n");
 			list_add_tail(&event->list, &ev_idle);
-			mutex_unlock(&hdmi_cec_data.lock);
+			mutex_unlock(&priv->lock);
 			return;
 		}
 
@@ -263,41 +263,41 @@ static void mxc_hdmi_cec_handle(u32 cec_stat)
 			event->msg[i] = hdmi_readb(HDMI_CEC_RX_DATA0 + i);
 
 		list_add_tail(&event->list, &ev_pending);
-		mutex_unlock(&hdmi_cec_data.lock);
+		mutex_unlock(&priv->lock);
 
 		wake_up(&rx_queue);
 	}
 	/*An error is detected on cec line (for initiator only). */
 	if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_INIT) {
-		hdmi_cec_data.tx_answer = cec_stat;
+		priv->tx_answer = cec_stat;
 		wake_up(&tx_queue);
 		return;
 	}
 	/*A frame is not acknowledged in a directly addressed message. Or a frame is negatively acknowledged in
 	a broadcast message (for initiator only).*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_NACK) {
-		hdmi_cec_data.send_error++;
-		hdmi_cec_data.tx_answer = cec_stat;
+		priv->send_error++;
+		priv->tx_answer = cec_stat;
 		wake_up(&tx_queue);
 	}
 	/*An error is notified by a follower. Abnormal logic data bit error (for follower).*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_FOLL) {
-		hdmi_cec_data.receive_error++;
+		priv->receive_error++;
 	}
 
 	/*HDMI cable disconnected: handle last*/
 	if (cec_stat & CEC_STAT0_EX_DISCONNECTED) {
 		pr_info("HDMI-CEC: link disconnected\n");
 
-		mutex_lock(&hdmi_cec_data.lock);
+		mutex_lock(&priv->lock);
 		event = alloc_event();
 		if (!event) {
-			mutex_unlock(&hdmi_cec_data.lock);
+			mutex_unlock(&priv->lock);
 			return;
 		}
 		event->event_type = MESSAGE_TYPE_DISCONNECTED;
 		list_add_tail(&event->list, &ev_pending);
-		mutex_unlock(&hdmi_cec_data.lock);
+		mutex_unlock(&priv->lock);
 
 		wake_up(&rx_queue);
 	}
@@ -306,32 +306,36 @@ static void mxc_hdmi_cec_handle(u32 cec_stat)
 static void mxc_hdmi_cec_worker(struct work_struct *work)
 {
 	unsigned long flags;
+	struct hdmi_cec_priv *priv = &hdmi_cec_data;
 
-	mxc_hdmi_cec_handle(hdmi_cec_data.cec_stat0);
+	mxc_hdmi_cec_handle(priv, priv->cec_stat0);
 
-	if (hdmi_cec_data.cec_stat0 & HDMI_IH_CEC_STAT0_EOM)
+	if (priv->cec_stat0 & HDMI_IH_CEC_STAT0_EOM)
 		hdmi_writeb(0x0, HDMI_CEC_LOCK);
 
-	spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
-	hdmi_cec_data.cec_stat0 = 0;
-	if (hdmi_cec_data.is_started)
+	spin_lock_irqsave(&priv->irq_lock, flags);
+	priv->cec_stat0 = 0;
+	if (priv->is_started)
 		hdmi_writeb(CEC_STAT0_MASK_DEFAULT, HDMI_IH_MUTE_CEC_STAT0);
-	spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
+	spin_unlock_irqrestore(&priv->irq_lock, flags);
 }
 
 static int hdmi_cec_open(struct inode *inode, struct file *file)
 {
-	mutex_lock(&hdmi_cec_data.lock);
-	if (hdmi_cec_data.open_count) {
-		mutex_unlock(&hdmi_cec_data.lock);
+	struct hdmi_cec_priv *priv = &hdmi_cec_data;
+
+	mutex_lock(&priv->lock);
+	if (priv->open_count) {
+		mutex_unlock(&priv->lock);
 		return -EBUSY;
 	}
-	hdmi_cec_data.open_count = 1;
-	file->private_data = (void *)(&hdmi_cec_data);
-	hdmi_cec_data.tx_answer = CEC_TX_AVAIL;
-	hdmi_cec_data.logical_address = 15;
-	hdmi_cec_data.is_started = false;
-	mutex_unlock(&hdmi_cec_data.lock);
+	file->private_data = priv;
+
+	priv->tx_answer = CEC_TX_AVAIL;
+	priv->logical_address = 15;
+	priv->is_started = false;
+	priv->open_count = 1;
+	mutex_unlock(&priv->lock);
 	return 0;
 }
 
@@ -340,32 +344,33 @@ static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 {
 	ssize_t len = 0;
 	struct hdmi_cec_event *event;
+	struct hdmi_cec_priv *priv = file->private_data;
 
 	pr_debug("function : %s\n", __func__);
 
-	mutex_lock(&hdmi_cec_data.lock);
+	mutex_lock(&priv->lock);
 
-	if (!hdmi_cec_data.is_started)
+	if (!priv->is_started)
 		len = -EACCES;
 	else if (count < offsetof(struct hdmi_cec_event, padding))
 		len = -EINVAL;
 
 	if (len < 0) {
-		mutex_unlock(&hdmi_cec_data.lock);
+		mutex_unlock(&priv->lock);
 		return len;
 	}
 
 	if (list_empty(&ev_pending)) {
 		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&hdmi_cec_data.lock);
+			mutex_unlock(&priv->lock);
 			return -EAGAIN;
 		}
 
 		do {
-			mutex_unlock(&hdmi_cec_data.lock);
+			mutex_unlock(&priv->lock);
 			if (wait_event_interruptible(rx_queue, !list_empty(&ev_pending)))
 				return -ERESTARTSYS;
-			mutex_lock(&hdmi_cec_data.lock);
+			mutex_lock(&priv->lock);
 		} while (list_empty(&ev_pending));
 	}
 
@@ -375,7 +380,7 @@ static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 	if (copy_to_user(buf, event, len))
 		len = -EFAULT;
 	list_move_tail(&event->list, &ev_idle);
-	mutex_unlock(&hdmi_cec_data.lock);
+	mutex_unlock(&priv->lock);
 
 	return len;
 }
@@ -386,16 +391,17 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	int ret = 0;
 	u8 i, msg_len, val;
 	u8 msg[MAX_MESSAGE_LEN];
+	struct hdmi_cec_priv *priv = file->private_data;
 
 	pr_debug("function : %s\n", __func__);
 
-	mutex_lock(&hdmi_cec_data.lock);
+	mutex_lock(&priv->lock);
 
-	if (!hdmi_cec_data.is_started)
+	if (!priv->is_started)
 		ret = -EACCES;
-	else if (hdmi_cec_data.tx_answer != CEC_TX_AVAIL)
+	else if (priv->tx_answer != CEC_TX_AVAIL)
 		ret = -EAGAIN;
-	else if (hdmi_cec_data.link_status != 1)
+	else if (priv->link_status != 1)
 		ret = -EAGAIN;
 	else if (count > MAX_MESSAGE_LEN)
 		ret = -EINVAL;
@@ -403,12 +409,12 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 		ret = -EACCES;
 
 	if (ret) {
-		mutex_unlock(&hdmi_cec_data.lock);
+		mutex_unlock(&priv->lock);
 		return ret;
 	}
 
-	hdmi_cec_data.send_error = 0;
-	hdmi_cec_data.tx_answer = CEC_TX_INPROGRESS;
+	priv->send_error = 0;
+	priv->tx_answer = CEC_TX_INPROGRESS;
 
 	msg_len = count;
 	hdmi_writeb(msg_len, HDMI_CEC_TX_CNT);
@@ -418,40 +424,41 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	val |= 0x01;
 	hdmi_writeb(val, HDMI_CEC_CTRL);
 
-	mutex_unlock(&hdmi_cec_data.lock);
+	mutex_unlock(&priv->lock);
 
 	ret = wait_event_interruptible_timeout(
-		tx_queue, hdmi_cec_data.tx_answer != CEC_TX_INPROGRESS, HZ);
+		tx_queue, priv->tx_answer != CEC_TX_INPROGRESS, HZ);
 
 	if (ret < 0)
 		ret = -ERESTARTSYS;
-	else if (hdmi_cec_data.tx_answer & HDMI_IH_CEC_STAT0_DONE)
+	else if (priv->tx_answer & HDMI_IH_CEC_STAT0_DONE)
 		ret = msg_len;	/* msg sent, ACK received */
-	else if (hdmi_cec_data.tx_answer & HDMI_IH_CEC_STAT0_NACK)
+	else if (priv->tx_answer & HDMI_IH_CEC_STAT0_NACK)
 		ret = -EIO;	/* msg sent, NACK received */
 	else
 		ret = -EPIPE;	/* other error */
 
-	hdmi_cec_data.tx_answer = CEC_TX_AVAIL;
+	priv->tx_answer = CEC_TX_AVAIL;
 	return ret;
 }
 
 void hdmi_cec_hpd_changed(unsigned int state)
 {
+	u32 cec_stat0;
 	unsigned long flags;
-	u32           cec_stat0;
+	struct hdmi_cec_priv *priv = &hdmi_cec_data;
 
 	pr_debug("function : %s\n", __func__);
 
 	link_status = state & 1;
 
 	if (is_initialized) {
-		spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
-		cec_stat0 = get_hpd_stat(&hdmi_cec_data);
-		spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
+		spin_lock_irqsave(&priv->irq_lock, flags);
+		cec_stat0 = get_hpd_stat(priv);
+		spin_unlock_irqrestore(&priv->irq_lock, flags);
 
 		if (cec_stat0)
-			mxc_hdmi_cec_handle(cec_stat0);
+			mxc_hdmi_cec_handle(priv, cec_stat0);
 	}
 }
 EXPORT_SYMBOL(hdmi_cec_hpd_changed);
@@ -515,35 +522,35 @@ void hdmi_cec_stop_device(void)
 }
 EXPORT_SYMBOL(hdmi_cec_stop_device);
 
-static long hdmi_cec_ioctl(struct file *file, u_int cmd,
-		     u_long arg)
+static long hdmi_cec_ioctl(struct file *file, u_int cmd, u_long arg)
 {
-	int ret = 0, status = 0;
-	u8 val = 0;
+	u8 val;
+	int ret = 0;
 	struct mxc_edid_cfg hdmi_edid_cfg;
+	struct hdmi_cec_priv *priv = file->private_data;
 
 	pr_debug("function : %s\n", __func__);
 
 	switch (cmd) {
 	case HDMICEC_IOC_SETLOGICALADDRESS:
-		mutex_lock(&hdmi_cec_data.lock);
-		if (!hdmi_cec_data.is_started) {
-			mutex_unlock(&hdmi_cec_data.lock);
+		mutex_lock(&priv->lock);
+		if (!priv->is_started) {
+			mutex_unlock(&priv->lock);
 			pr_err("Trying to set logical address while not started\n");
 			return -EACCES;
 		}
-		hdmi_cec_data.logical_address = (u8)arg;
-		if (hdmi_cec_data.logical_address <= 7) {
-			val = 1 << hdmi_cec_data.logical_address;
+		priv->logical_address = (u8)arg;
+		if (priv->logical_address <= 7) {
+			val = 1 << priv->logical_address;
 			hdmi_writeb(val, HDMI_CEC_ADDR_L);
 			hdmi_writeb(0, HDMI_CEC_ADDR_H);
-		} else if (hdmi_cec_data.logical_address > 7 && hdmi_cec_data.logical_address <= 15) {
-			val = 1 << (hdmi_cec_data.logical_address - 8);
+		} else if (priv->logical_address <= 15) {
+			val = 1 << (priv->logical_address - 8);
 			hdmi_writeb(val, HDMI_CEC_ADDR_H);
 			hdmi_writeb(0, HDMI_CEC_ADDR_L);
 		} else
 			ret = -EINVAL;
-		mutex_unlock(&hdmi_cec_data.lock);
+		mutex_unlock(&priv->lock);
 		break;
 	case HDMICEC_IOC_STARTDEVICE:
 		hdmi_cec_start_device();
@@ -553,10 +560,9 @@ static long hdmi_cec_ioctl(struct file *file, u_int cmd,
 		break;
 	case HDMICEC_IOC_GETPHYADDRESS:
 		hdmi_get_edid_cfg(&hdmi_edid_cfg);
-		status = copy_to_user((void __user *)arg,
-					 &hdmi_edid_cfg.physical_address,
-					 4*sizeof(u8));
-		if (status)
+		if (copy_to_user((void __user *)arg,
+				 &hdmi_edid_cfg.physical_address,
+				 4 * sizeof(u8)))
 			ret = -EFAULT;
 		break;
 	default:
@@ -568,18 +574,20 @@ static long hdmi_cec_ioctl(struct file *file, u_int cmd,
 
 static int hdmi_cec_release(struct inode *inode, struct file *file)
 {
+	struct hdmi_cec_priv *priv = &hdmi_cec_data;
+
 	pr_debug("function : %s\n", __func__);
 
-	mutex_lock(&hdmi_cec_data.lock);
-	if (hdmi_cec_data.open_count) {
-		hdmi_cec_data.open_count = 0;
-		hdmi_cec_data.is_started = false;
-		hdmi_cec_data.logical_address = 15;
-		hdmi_cec_data.tx_answer = CEC_TX_AVAIL;
+	mutex_lock(&priv->lock);
+	if (priv->open_count) {
+		priv->open_count = 0;
+		priv->is_started = false;
+		priv->logical_address = 15;
+		priv->tx_answer = CEC_TX_AVAIL;
 
 		free_events();
 	}
-	mutex_unlock(&hdmi_cec_data.lock);
+	mutex_unlock(&priv->lock);
 
 	return 0;
 }
@@ -587,20 +595,21 @@ static int hdmi_cec_release(struct inode *inode, struct file *file)
 static unsigned int hdmi_cec_poll(struct file *file, poll_table *wait)
 {
 	unsigned int mask = 0;
+	struct hdmi_cec_priv *priv = file->private_data;
 
 	pr_debug("function : %s\n", __func__);
 
 	poll_wait(file, &rx_queue, wait);
 	poll_wait(file, &tx_queue, wait);
 
-	if (hdmi_cec_data.link_status == 1 &&
-	    hdmi_cec_data.tx_answer == CEC_TX_AVAIL)
+	if (priv->link_status == 1 &&
+	    priv->tx_answer == CEC_TX_AVAIL)
 		mask |= POLLOUT | POLLWRNORM;
 
-	mutex_lock(&hdmi_cec_data.lock);
+	mutex_lock(&priv->lock);
 	if (!list_empty(&ev_pending))
 		mask |= POLLIN | POLLRDNORM;
-	mutex_unlock(&hdmi_cec_data.lock);
+	mutex_unlock(&priv->lock);
 
 	return mask;
 }
-- 
1.9.1


==============================================================
file 0010-assign-minor-to-vhci.patch
==============================================================

From 27b8b64082db6cdfda751e81e56c0f668053834b Mon Sep 17 00:00:00 2001
From: Lucas De Marchi <lucas.demarchi@intel.com>
Date: Tue, 18 Feb 2014 02:19:26 -0300
Subject: [PATCH] Bluetooth: allocate static minor for vhci

Commit bfacbb9 (Bluetooth: Use devname:vhci module alias for virtual HCI
driver) added the module alias to hci_vhci module so it's possible to
create the /dev/vhci node. However creating an alias without
specifying the minor doesn't allow us to create the node ahead,
triggerring module auto-load when it's first accessed.

Starting with depmod from kmod 16 we started to warn if there's a
devname alias without specifying the major and minor.

Let's do the same done for uhid, kvm, fuse and others, specifying a
fixed minor. In systems with systemd as the init the following will
happen: on early boot systemd will call "kmod static-nodes" to read
/lib/modules/$(uname -r)/modules.devname and then create the nodes. When
first accessed these "dead" nodes will trigger the module loading.

Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
---
 Documentation/devices.txt    | 1 +
 drivers/bluetooth/hci_vhci.c | 3 ++-
 include/linux/miscdevice.h   | 1 +
 3 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/Documentation/devices.txt b/Documentation/devices.txt
index 10378cc..04356f5 100644
--- a/Documentation/devices.txt
+++ b/Documentation/devices.txt
@@ -353,6 +353,7 @@ Your cooperation is appreciated.
 		133 = /dev/exttrp	External device trap
 		134 = /dev/apm_bios	Advanced Power Management BIOS
 		135 = /dev/rtc		Real Time Clock
+		137 = /dev/vhci		Bluetooth virtual HCI driver
 		139 = /dev/openprom	SPARC OpenBoot PROM
 		140 = /dev/relay8	Berkshire Products Octal relay card
 		141 = /dev/relay16	Berkshire Products ISO-16 relay card
diff --git a/drivers/bluetooth/hci_vhci.c b/drivers/bluetooth/hci_vhci.c
index 1ef6990..add1c6a 100644
--- a/drivers/bluetooth/hci_vhci.c
+++ b/drivers/bluetooth/hci_vhci.c
@@ -360,7 +360,7 @@ static const struct file_operations vhci_fops = {
 static struct miscdevice vhci_miscdev= {
 	.name	= "vhci",
 	.fops	= &vhci_fops,
-	.minor	= MISC_DYNAMIC_MINOR,
+	.minor	= VHCI_MINOR,
 };
 
 static int __init vhci_init(void)
@@ -386,3 +386,4 @@ MODULE_DESCRIPTION("Bluetooth virtual HCI driver ver " VERSION);
 MODULE_VERSION(VERSION);
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("devname:vhci");
+MODULE_ALIAS_MISCDEV(VHCI_MINOR);
diff --git a/include/linux/miscdevice.h b/include/linux/miscdevice.h
index 3737f72..7bb6148 100644
--- a/include/linux/miscdevice.h
+++ b/include/linux/miscdevice.h
@@ -23,6 +23,7 @@
 #define TEMP_MINOR		131	/* Temperature Sensor */
 #define RTC_MINOR		135
 #define EFI_RTC_MINOR		136	/* EFI Time services */
+#define VHCI_MINOR		137
 #define SUN_OPENPROM_MINOR	139
 #define DMAPI_MINOR		140	/* DMAPI */
 #define NVRAM_MINOR		144

==============================================================
file 0011-MXC-CEC-Re-order-functions-and-remove-debug-trace-me.patch
==============================================================

From aeefcbe8831cbdd5a54a1144b89a4d8e2a427e2c Mon Sep 17 00:00:00 2001
From: warped-rudi <r.ihle@s-t.de>
Date: Wed, 9 Nov 2016 09:27:39 +0100
Subject: [PATCH] MXC-CEC: Re-order functions and remove debug trace messages

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 239 ++++++++++++++++++------------------
 1 file changed, 118 insertions(+), 121 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index 80344d9..fcf2a28 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -241,6 +241,7 @@ static void mxc_hdmi_cec_handle(struct hdmi_cec_priv *priv, u32 cec_stat)
 		priv->tx_answer = cec_stat;
 		wake_up(&tx_queue);
 	}
+
 	/*EOM is detected so that the received data is ready in the receiver data buffer*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_EOM) {
 		mutex_lock(&priv->lock);
@@ -267,12 +268,14 @@ static void mxc_hdmi_cec_handle(struct hdmi_cec_priv *priv, u32 cec_stat)
 
 		wake_up(&rx_queue);
 	}
+
 	/*An error is detected on cec line (for initiator only). */
 	if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_INIT) {
 		priv->tx_answer = cec_stat;
 		wake_up(&tx_queue);
 		return;
 	}
+
 	/*A frame is not acknowledged in a directly addressed message. Or a frame is negatively acknowledged in
 	a broadcast message (for initiator only).*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_NACK) {
@@ -280,6 +283,7 @@ static void mxc_hdmi_cec_handle(struct hdmi_cec_priv *priv, u32 cec_stat)
 		priv->tx_answer = cec_stat;
 		wake_up(&tx_queue);
 	}
+
 	/*An error is notified by a follower. Abnormal logic data bit error (for follower).*/
 	if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_FOLL) {
 		priv->receive_error++;
@@ -320,6 +324,89 @@ static void mxc_hdmi_cec_worker(struct work_struct *work)
 	spin_unlock_irqrestore(&priv->irq_lock, flags);
 }
 
+
+void hdmi_cec_hpd_changed(unsigned int state)
+{
+	u32 cec_stat0;
+	unsigned long flags;
+	struct hdmi_cec_priv *priv = &hdmi_cec_data;
+
+	pr_debug("function : %s (%d)\n", __func__, state);
+
+	link_status = state & 1;
+
+	if (is_initialized) {
+		spin_lock_irqsave(&priv->irq_lock, flags);
+		cec_stat0 = get_hpd_stat(priv);
+		spin_unlock_irqrestore(&priv->irq_lock, flags);
+
+		if (cec_stat0)
+			mxc_hdmi_cec_handle(priv, cec_stat0);
+	}
+}
+EXPORT_SYMBOL(hdmi_cec_hpd_changed);
+
+void hdmi_cec_start_device(void)
+{
+	u8 val;
+	unsigned long flags;
+
+	if (!is_initialized) {
+		want_start = 1;
+		return;
+	}
+
+	spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
+
+	val = hdmi_readb(HDMI_MC_CLKDIS);
+	val &= ~HDMI_MC_CLKDIS_CECCLK_DISABLE;
+	hdmi_writeb(val, HDMI_MC_CLKDIS);
+	hdmi_writeb(0x02, HDMI_CEC_CTRL);
+	/* Force read unlock */
+	hdmi_writeb(0x0, HDMI_CEC_LOCK);
+
+	val = HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_NACK |
+	      HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
+	hdmi_writeb(val, HDMI_CEC_POLARITY);
+
+	val = CEC_STAT0_MASK_DEFAULT;
+	hdmi_writeb(val, HDMI_CEC_MASK);
+	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
+	hdmi_cec_data.link_status = link_status;
+	hdmi_cec_data.is_started = true;
+
+	spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
+}
+EXPORT_SYMBOL(hdmi_cec_start_device);
+
+void hdmi_cec_stop_device(void)
+{ 
+	u8 val;
+	unsigned long flags;
+
+	if (!is_initialized) {
+		want_start = 0;
+		return;
+	}
+
+	spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
+
+	hdmi_cec_data.is_started = false;
+	hdmi_writeb(0x10, HDMI_CEC_CTRL);
+	val = CEC_STAT0_MASK_ALL;
+	hdmi_writeb(val, HDMI_CEC_MASK);
+	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
+
+	hdmi_writeb(0x0, HDMI_CEC_POLARITY);
+	val = hdmi_readb(HDMI_MC_CLKDIS);
+	val |= HDMI_MC_CLKDIS_CECCLK_DISABLE;
+	hdmi_writeb(val, HDMI_MC_CLKDIS);
+
+	spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
+}
+EXPORT_SYMBOL(hdmi_cec_stop_device);
+
+
 static int hdmi_cec_open(struct inode *inode, struct file *file)
 {
 	struct hdmi_cec_priv *priv = &hdmi_cec_data;
@@ -339,6 +426,24 @@ static int hdmi_cec_open(struct inode *inode, struct file *file)
 	return 0;
 }
 
+static int hdmi_cec_release(struct inode *inode, struct file *file)
+{
+	struct hdmi_cec_priv *priv = file->private_data;
+
+	mutex_lock(&priv->lock);
+	if (priv->open_count) {
+		priv->open_count = 0;
+		priv->is_started = false;
+		priv->logical_address = 15;
+		priv->tx_answer = CEC_TX_AVAIL;
+
+		free_events();
+	}
+	mutex_unlock(&priv->lock);
+
+	return 0;
+}
+
 static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 			    loff_t *ppos)
 {
@@ -346,8 +451,6 @@ static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 	struct hdmi_cec_event *event;
 	struct hdmi_cec_priv *priv = file->private_data;
 
-	pr_debug("function : %s\n", __func__);
-
 	mutex_lock(&priv->lock);
 
 	if (!priv->is_started)
@@ -393,8 +496,6 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	u8 msg[MAX_MESSAGE_LEN];
 	struct hdmi_cec_priv *priv = file->private_data;
 
-	pr_debug("function : %s\n", __func__);
-
 	mutex_lock(&priv->lock);
 
 	if (!priv->is_started)
@@ -442,85 +543,25 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	return ret;
 }
 
-void hdmi_cec_hpd_changed(unsigned int state)
-{
-	u32 cec_stat0;
-	unsigned long flags;
-	struct hdmi_cec_priv *priv = &hdmi_cec_data;
-
-	pr_debug("function : %s\n", __func__);
-
-	link_status = state & 1;
-
-	if (is_initialized) {
-		spin_lock_irqsave(&priv->irq_lock, flags);
-		cec_stat0 = get_hpd_stat(priv);
-		spin_unlock_irqrestore(&priv->irq_lock, flags);
-
-		if (cec_stat0)
-			mxc_hdmi_cec_handle(priv, cec_stat0);
-	}
-}
-EXPORT_SYMBOL(hdmi_cec_hpd_changed);
-
-void hdmi_cec_start_device(void)
+static unsigned int hdmi_cec_poll(struct file *file, poll_table *wait)
 {
-	u8 val;
-	unsigned long flags;
-
-	if (!is_initialized) {
-		want_start = 1;
-		return;
-	}
-
-	spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
-
-	val = hdmi_readb(HDMI_MC_CLKDIS);
-	val &= ~HDMI_MC_CLKDIS_CECCLK_DISABLE;
-	hdmi_writeb(val, HDMI_MC_CLKDIS);
-	hdmi_writeb(0x02, HDMI_CEC_CTRL);
-	/* Force read unlock */
-	hdmi_writeb(0x0, HDMI_CEC_LOCK);
-
-	val = HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
-	hdmi_writeb(val, HDMI_CEC_POLARITY);
-
-	val = CEC_STAT0_MASK_DEFAULT;
-	hdmi_writeb(val, HDMI_CEC_MASK);
-	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
-	hdmi_cec_data.link_status = link_status;
-	hdmi_cec_data.is_started = true;
-
-	spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
-}
-EXPORT_SYMBOL(hdmi_cec_start_device);
-
-void hdmi_cec_stop_device(void)
-{ 
-	u8 val;
-	unsigned long flags;
-
-	if (!is_initialized) {
-		want_start = 0;
-		return;
-	}
+	unsigned int mask = 0;
+	struct hdmi_cec_priv *priv = file->private_data;
 
-	spin_lock_irqsave(&hdmi_cec_data.irq_lock, flags);
+	poll_wait(file, &rx_queue, wait);
+	poll_wait(file, &tx_queue, wait);
 
-	hdmi_cec_data.is_started = false;
-	hdmi_writeb(0x10, HDMI_CEC_CTRL);
-	val = CEC_STAT0_MASK_ALL;
-	hdmi_writeb(val, HDMI_CEC_MASK);
-	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
+	if (priv->link_status == 1 &&
+	    priv->tx_answer == CEC_TX_AVAIL)
+		mask |= POLLOUT | POLLWRNORM;
 
-	hdmi_writeb(0x0, HDMI_CEC_POLARITY);
-	val = hdmi_readb(HDMI_MC_CLKDIS);
-	val |= HDMI_MC_CLKDIS_CECCLK_DISABLE;
-	hdmi_writeb(val, HDMI_MC_CLKDIS);
+	mutex_lock(&priv->lock);
+	if (!list_empty(&ev_pending))
+		mask |= POLLIN | POLLRDNORM;
+	mutex_unlock(&priv->lock);
 
-	spin_unlock_irqrestore(&hdmi_cec_data.irq_lock, flags);
+	return mask;
 }
-EXPORT_SYMBOL(hdmi_cec_stop_device);
 
 static long hdmi_cec_ioctl(struct file *file, u_int cmd, u_long arg)
 {
@@ -529,8 +570,6 @@ static long hdmi_cec_ioctl(struct file *file, u_int cmd, u_long arg)
 	struct mxc_edid_cfg hdmi_edid_cfg;
 	struct hdmi_cec_priv *priv = file->private_data;
 
-	pr_debug("function : %s\n", __func__);
-
 	switch (cmd) {
 	case HDMICEC_IOC_SETLOGICALADDRESS:
 		mutex_lock(&priv->lock);
@@ -572,48 +611,6 @@ static long hdmi_cec_ioctl(struct file *file, u_int cmd, u_long arg)
     return ret;
 }
 
-static int hdmi_cec_release(struct inode *inode, struct file *file)
-{
-	struct hdmi_cec_priv *priv = &hdmi_cec_data;
-
-	pr_debug("function : %s\n", __func__);
-
-	mutex_lock(&priv->lock);
-	if (priv->open_count) {
-		priv->open_count = 0;
-		priv->is_started = false;
-		priv->logical_address = 15;
-		priv->tx_answer = CEC_TX_AVAIL;
-
-		free_events();
-	}
-	mutex_unlock(&priv->lock);
-
-	return 0;
-}
-
-static unsigned int hdmi_cec_poll(struct file *file, poll_table *wait)
-{
-	unsigned int mask = 0;
-	struct hdmi_cec_priv *priv = file->private_data;
-
-	pr_debug("function : %s\n", __func__);
-
-	poll_wait(file, &rx_queue, wait);
-	poll_wait(file, &tx_queue, wait);
-
-	if (priv->link_status == 1 &&
-	    priv->tx_answer == CEC_TX_AVAIL)
-		mask |= POLLOUT | POLLWRNORM;
-
-	mutex_lock(&priv->lock);
-	if (!list_empty(&ev_pending))
-		mask |= POLLIN | POLLRDNORM;
-	mutex_unlock(&priv->lock);
-
-	return mask;
-}
-
 
 const struct file_operations hdmi_cec_fops = {
 	.owner = THIS_MODULE,
-- 
1.9.1


==============================================================
file 0012-MXC-CEC-Provide-send-notifications.patch
==============================================================

From 73230c020f3fb1385046890df1695d1bc2e6082e Mon Sep 17 00:00:00 2001
From: warped-rudi <r.ihle@s-t.de>
Date: Wed, 9 Nov 2016 09:27:40 +0100
Subject: [PATCH] MXC-CEC: Provide send notifications

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index fcf2a28..dfb4aa4 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -494,6 +494,7 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	int ret = 0;
 	u8 i, msg_len, val;
 	u8 msg[MAX_MESSAGE_LEN];
+	struct hdmi_cec_event *event;
 	struct hdmi_cec_priv *priv = file->private_data;
 
 	mutex_lock(&priv->lock);
@@ -540,6 +541,24 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 		ret = -EPIPE;	/* other error */
 
 	priv->tx_answer = CEC_TX_AVAIL;
+
+	if (ret >= 0 || ret == -EIO) {
+		mutex_lock(&priv->lock);
+
+		event = alloc_event();
+		if (event) {
+			event->event_type = (ret == -EIO) ?
+				MESSAGE_TYPE_NOACK : MESSAGE_TYPE_SEND_SUCCESS;
+			event->msg_len = msg_len;
+			memcpy(event->msg, msg, msg_len);
+
+			list_add_tail(&event->list, &ev_pending);
+			wake_up(&rx_queue);
+		}
+
+		mutex_unlock(&priv->lock);
+	}
+
 	return ret;
 }
 
-- 
1.9.1


==============================================================
file 0013-MXC-CEC-Enable-transmissions-retries-in-case-of-erro.patch
==============================================================

From 0fd44cc4dc2fb1f5a0cb26aa74a2c11af1b0d79e Mon Sep 17 00:00:00 2001
From: warped-rudi <r.ihle@s-t.de>
Date: Wed, 9 Nov 2016 17:25:01 +0100
Subject: [PATCH] MXC-CEC: Enable transmissions retries in case of errors and
 NACKs

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 29 +++++++++++++++--------------
 1 file changed, 15 insertions(+), 14 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index dfb4aa4..4d22e38 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -58,6 +58,9 @@
 #define CEC_TX_INPROGRESS		-1
 #define CEC_TX_AVAIL			0
 
+#define	CEC_TX_RETRIES			3
+
+
 /* These flags must not collide with HDMI_IH_CEC_STAT0_xxxx */
 #define	CEC_STAT0_EX_CONNECTED		0x0100
 #define	CEC_STAT0_EX_DISCONNECTED	0x0200
@@ -214,6 +217,7 @@ static irqreturn_t mxc_hdmi_cec_isr(int irq, void *data)
 static void mxc_hdmi_cec_handle(struct hdmi_cec_priv *priv, u32 cec_stat)
 {
 	int i;
+	u8 val;
 	struct hdmi_cec_event *event;
 
 	if (!priv->open_count)
@@ -270,18 +274,16 @@ static void mxc_hdmi_cec_handle(struct hdmi_cec_priv *priv, u32 cec_stat)
 	}
 
 	/*An error is detected on cec line (for initiator only). */
-	if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_INIT) {
-		priv->tx_answer = cec_stat;
-		wake_up(&tx_queue);
-		return;
-	}
-
 	/*A frame is not acknowledged in a directly addressed message. Or a frame is negatively acknowledged in
 	a broadcast message (for initiator only).*/
-	if (cec_stat & HDMI_IH_CEC_STAT0_NACK) {
-		priv->send_error++;
-		priv->tx_answer = cec_stat;
-		wake_up(&tx_queue);
+	if (cec_stat & (HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_NACK)) {
+		if (++priv->send_error < CEC_TX_RETRIES) {
+			val = hdmi_readb(HDMI_CEC_CTRL) & ~0x07;
+			hdmi_writeb(val | 0x01, HDMI_CEC_CTRL);
+		} else {
+			priv->tx_answer = cec_stat;
+			wake_up(&tx_queue);
+		}
 	}
 
 	/*An error is notified by a follower. Abnormal logic data bit error (for follower).*/
@@ -521,10 +523,9 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	msg_len = count;
 	hdmi_writeb(msg_len, HDMI_CEC_TX_CNT);
 	for (i = 0; i < msg_len; i++)
-		hdmi_writeb(msg[i], HDMI_CEC_TX_DATA0+i);
-	val = hdmi_readb(HDMI_CEC_CTRL);
-	val |= 0x01;
-	hdmi_writeb(val, HDMI_CEC_CTRL);
+		hdmi_writeb(msg[i], HDMI_CEC_TX_DATA0 + i);
+	val = hdmi_readb(HDMI_CEC_CTRL) & ~0x07;
+	hdmi_writeb(val | 0x03, HDMI_CEC_CTRL);
 
 	mutex_unlock(&priv->lock);
 
-- 
1.9.1


==============================================================
file 1100-ARM-Avoid-crash-on-power-off-and-reduce-power-consum.patch
==============================================================

From 7a4bc357a0d2477c0dcdf2a1c471e57050dec041 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Sat, 20 Sep 2014 14:05:50 +0200
Subject: [PATCH] ARM: Avoid crash on power off and reduce power consumption
 in 'halt' state.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 arch/arm/kernel/process.c |   19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 1bdd78b..70655b9 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -119,6 +119,17 @@ static void null_restart(enum reboot_mode reboot_mode, const char *cmd)
 }
 
 /*
+ *  Enter non-interruptable CPU halt state
+ */
+static void cpu_halt(void)
+{
+	local_irq_disable();
+	
+	while (1)
+		cpu_do_idle();
+}
+
+/*
  * Function pointers to optional machine specific functions
  */
 void (*pm_power_off)(void);
@@ -202,8 +213,7 @@ void machine_halt(void)
 	local_irq_disable();
 	smp_send_stop();
 
-	local_irq_disable();
-	while (1);
+	cpu_halt();
 }
 
 /*
@@ -219,6 +229,8 @@ void machine_power_off(void)
 
 	if (pm_power_off)
 		pm_power_off();
+	
+	cpu_halt();
 }
 
 /*
@@ -244,8 +256,7 @@ void machine_restart(char *cmd)
 
 	/* Whoops - the platform was unable to reboot. Tell the user! */
 	printk("Reboot failed -- System halted\n");
-	local_irq_disable();
-	while (1);
+	cpu_halt();
 }
 
 void __show_regs(struct pt_regs *regs)
-- 
1.7.9.5


==============================================================
file 1101-ARM-Disable-timer-events-before-entering-halt-state.patch
==============================================================

From ae0f301a11bb9d5e484d48238cf15082928a7241 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Sun, 21 Sep 2014 13:53:21 +0200
Subject: [PATCH] ARM: Disable timer events before entering `halt' state.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 arch/arm/kernel/process.c |    3 ++-
 arch/arm/mach-imx/time.c  |   11 +++++++++++
 2 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 70655b9..d1e4763 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -123,8 +123,9 @@ static void null_restart(enum reboot_mode reboot_mode, const char *cmd)
  */
 static void cpu_halt(void)
 {
+	clockevents_suspend();
+
 	local_irq_disable();
-	
 	while (1)
 		cpu_do_idle();
 }
diff --git a/arch/arm/mach-imx/time.c b/arch/arm/mach-imx/time.c
index ae61dfd..75afcf9 100644
--- a/arch/arm/mach-imx/time.c
+++ b/arch/arm/mach-imx/time.c
@@ -232,6 +232,16 @@ static void mxc_set_mode(enum clock_event_mode mode,
 	}
 }
 
+
+/*
+ * Shutdown timer
+ */
+static void mxc_suspend(struct clock_event_device *evt)
+{
+	mxc_set_mode(CLOCK_EVT_MODE_SHUTDOWN, evt);
+}
+
+
 /*
  * IRQ handler for the timer
  */
@@ -262,6 +272,7 @@ static struct clock_event_device clockevent_mxc = {
 	.name		= "mxc_timer1",
 	.features	= CLOCK_EVT_FEAT_ONESHOT,
 	.set_mode	= mxc_set_mode,
+	.suspend	= mxc_suspend,
 	.set_next_event	= mx1_2_set_next_event,
 	.rating		= 200,
 };
-- 
1.7.9.5


==============================================================
file 1104-interlaced-fix.patch
==============================================================

From d6c338100ddd885a7acb1d0cf12da90fa7ac2b93 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Wed, 30 Dec 2015 11:01:32 +0100
Subject: [PATCH] video: ipu_disp: Fix internal VSYNC clock for interlaced
 modes

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/mxc/ipu3/ipu_disp.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
index b5e21c5..96464b2 100644
--- a/drivers/mxc/ipu3/ipu_disp.c
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -2065,7 +2065,7 @@ int32_t ipu_init_sync_panel(struct ipu_soc *ipu, int disp, uint32_t pixel_clk,
 				_ipu_di_sync_config(ipu,
 						disp, 		/* display */
 						DI_SYNC_COUNT_1, 		/* counter */
-						v_total*2 - 1, 	/* run count */
+						v_total - 1, 	/* run count */
 						(3 - 1),	/* run_resolution, counter 1 can reference to counter 6,7,8 with run_resolution=2,3,4 */
 						1, 		/* offset */
 						(3 - 1), 	/* offset resolution, 3=counter 7 */
-- 
1.9.1


==============================================================
file 1110-video-mxc_hdmi-Use-common-function-to-insert-video-m.patch
==============================================================

From a86bd823319cf21eec118f238e2d3e97ede3690f Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Thu, 24 Dec 2015 08:13:24 +0100
Subject: [PATCH] video: mxc_hdmi: Use common function to insert video modes

To simplify further development we move the mode list entry
creation into a single function.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_hdmi.c | 145 ++++++++++++++++++-------------------------
 1 file changed, 60 insertions(+), 85 deletions(-)

diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 55c39e1..f71c1dd 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -1740,7 +1740,8 @@ static int mxc_edid_read_internal(struct mxc_hdmi *hdmi, unsigned char *edid,
 
 static int mxc_hdmi_read_edid(struct mxc_hdmi *hdmi)
 {
-	int ret;
+	int ret, n;
+	struct fb_videomode *mode;
 	u8 edid_old[HDMI_EDID_LEN];
 	u8 clkdis;
 
@@ -1774,19 +1775,36 @@ static int mxc_hdmi_read_edid(struct mxc_hdmi *hdmi)
 
 	}
 
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&hdmi->pdev->dev, "Failed to read EDID\n");
 		return HDMI_EDID_FAIL;
+	}
 
 	if (memcmp(edid_old, hdmi->edid, HDMI_EDID_LEN) == 0) {
-		dev_info(&hdmi->pdev->dev, "same edid\n");
+		dev_info(&hdmi->pdev->dev, "Same EDID\n");
 		return HDMI_EDID_SAME;
 	}
 
 	if (hdmi->fbi->monspecs.modedb_len == 0) {
-		dev_info(&hdmi->pdev->dev, "No modes read from edid\n");
+		dev_warn(&hdmi->pdev->dev, "No modes read from EDID\n");
 		return HDMI_EDID_NO_MODES;
 	}
 
+	/* TODO: Is this really neccessary? */
+	mode = hdmi->fbi->monspecs.modedb;
+	n = hdmi->fbi->monspecs.modedb_len;
+	while (n--) {
+		if ((mode->flag & FB_MODE_IS_STANDARD) &&
+		    !(mode->vmode & FB_VMODE_ASPECT_MASK)) {
+			if (mode->yres == (mode->xres * 3)/4)
+				mode->vmode |= FB_VMODE_ASPECT_4_3;
+			else
+				mode->vmode |= FB_VMODE_ASPECT_16_9;
+		}
+
+		mode++;
+	}
+
 	return HDMI_EDID_SUCCESS;
 }
 
@@ -1928,51 +1946,53 @@ static void mxc_hdmi_notify_fb(struct mxc_hdmi *hdmi, bool force_all)
 	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
 }
 
-static void mxc_hdmi_edid_rebuild_modelist(struct mxc_hdmi *hdmi)
+static void mxc_hdmi_create_modelist(struct mxc_hdmi *hdmi, int from_edid)
 {
-	int i, vic;
-	struct fb_videomode *mode;
+	struct fb_videomode mode;
+	int i, vic, mode_count = ARRAY_SIZE(mxc_cea_mode);
+	const struct fb_videomode *mode_data = mxc_cea_mode;
+
+	if (from_edid) {
+		mode_data = hdmi->fbi->monspecs.modedb;
+		mode_count = hdmi->fbi->monspecs.modedb_len;
+	}
 
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
 
 	console_lock();
 
 	fb_destroy_modelist(&hdmi->fbi->modelist);
+
+	/* Always insert VGA mode */
 	fb_add_videomode(&vga_mode, &hdmi->fbi->modelist);
 
-	for (i = 0; i < hdmi->fbi->monspecs.modedb_len; i++) {
-		/*
-		 * We might check here if mode is supported by HDMI.
-		 * We do not currently support interlaced modes.
-		 * And add CEA modes in the modelist.
-		 */
-		mode = &hdmi->fbi->monspecs.modedb[i];
-
-		vic = mxc_edid_mode_to_vic(mode);
-		if (hdmi->edid_cfg.hdmi_cap &&
-		    (vic == 0))
+	for (i = 0; i < mode_count; i++) {
+		vic = from_edid ? mxc_edid_mode_to_vic(&mode_data[i]) : i;
+
+		if (mode_data[i].xres == 0 ||
+		    (hdmi->edid_cfg.hdmi_cap && vic == 0))
 			continue;
 
-		if (!(mode->vmode & FB_VMODE_ASPECT_MASK)) {
-			if (mode->yres == (mode->xres * 3)/4)
-				mode->vmode |= FB_VMODE_ASPECT_4_3;
-			else
-				mode->vmode |= FB_VMODE_ASPECT_16_9;
-		}
+		mode = mode_data[i];
+
+		/* TODO: Discuss if we should always set default modes as standard */
+		if (!from_edid /*&& ignore_edid*/)
+			mode.flag |= FB_MODE_IS_STANDARD;
 
-		if (fb_add_videomode(mode, &hdmi->fbi->modelist))
+		if (fb_add_videomode(&mode, &hdmi->fbi->modelist))
 			continue;
 
 		dev_dbg(&hdmi->pdev->dev, "Added mode: %d, vic: %d", i, vic);
 		dev_dbg(&hdmi->pdev->dev,
-			"xres = %d, yres = %d, ratio = %s, freq = %d, vmode = %d, flag = %d\n",
-			hdmi->fbi->monspecs.modedb[i].xres,
-			hdmi->fbi->monspecs.modedb[i].yres,
-			mode->vmode & FB_VMODE_ASPECT_4_3 ? "4/3" :
-			    mode->vmode & FB_VMODE_ASPECT_16_9 ? "16/9" : "n/a",
-			hdmi->fbi->monspecs.modedb[i].refresh,
-			hdmi->fbi->monspecs.modedb[i].vmode,
-			hdmi->fbi->monspecs.modedb[i].flag);
+			"xres = %d, yres = %d, scan = %c, ratio = %s, freq = %d, vmode = %d, flag = %d\n",
+			mode.xres,
+			mode.yres,
+			mode.vmode & FB_VMODE_INTERLACED ? 'i' : 'p',
+			mode.vmode & FB_VMODE_ASPECT_4_3 ? "4/3" :
+			    mode.vmode & FB_VMODE_ASPECT_16_9 ? "16/9" : "n/a",
+			mode.refresh,
+			mode.vmode,
+			mode.flag);
 	}
 
 	fb_new_modelist(hdmi->fbi);
@@ -1986,36 +2006,6 @@ static void  mxc_hdmi_default_edid_cfg(struct mxc_hdmi *hdmi)
 	hdmi->edid_cfg.hdmi_cap = true;
 }
 
-static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
-{
-	u32 i;
-	struct fb_videomode mode;
-
-	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
-
-	/* If not EDID data read, set up default modelist  */
-	dev_info(&hdmi->pdev->dev, "No modes read from edid\n");
-	dev_info(&hdmi->pdev->dev, "create default modelist\n");
-
-	console_lock();
-
-	fb_destroy_modelist(&hdmi->fbi->modelist);
-
-	/*Add all no interlaced CEA mode to default modelist */
-	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
-		mode = mxc_cea_mode[i];
-		if (!(mode.vmode & FB_VMODE_INTERLACED) && (mode.xres != 0)) {
-			if (ignore_edid)
-				mode.flag |= FB_MODE_IS_STANDARD;
-			fb_add_videomode(&mode, &hdmi->fbi->modelist);
-		}
-	}
-
-	fb_new_modelist(hdmi->fbi);
-
-	console_unlock();
-}
-
 static void mxc_hdmi_set_mode(struct mxc_hdmi *hdmi, int edid_status)
 {
 	const struct fb_videomode *mode;
@@ -2108,7 +2098,7 @@ static void mxc_hdmi_cable_connected(struct mxc_hdmi *hdmi)
 	/* HDMI Initialization Steps D, E, F */
 	switch (edid_status) {
 	case HDMI_EDID_SUCCESS:
-		mxc_hdmi_edid_rebuild_modelist(hdmi);
+		mxc_hdmi_create_modelist(hdmi, true);
 		break;
 
 	/* Nothing to do if EDID same */
@@ -2120,7 +2110,7 @@ static void mxc_hdmi_cable_connected(struct mxc_hdmi *hdmi)
 		/* No break here  */
 	case HDMI_EDID_NO_MODES:
 	default:
-		mxc_hdmi_default_modelist(hdmi);
+		mxc_hdmi_create_modelist(hdmi, false);
 		break;
 	}
 
@@ -2676,7 +2666,6 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 			      struct mxc_dispdrv_setting *setting)
 {
 	int ret = 0;
-	u32 i;
 	const struct fb_videomode *mode;
 	struct fb_videomode m;
 	struct mxc_hdmi *hdmi = mxc_dispdrv_getdata(disp);
@@ -2787,31 +2776,17 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 
 	spin_lock_init(&hdmi->irq_lock);
 
-	/* Set the default mode and modelist when disp init. */
+	/* Create default modelist */
+	mxc_hdmi_create_modelist(hdmi, false);
+
+	/* Set the default mode when disp init. */
 	fb_find_mode(&hdmi->fbi->var, hdmi->fbi,
 		     hdmi->dft_mode_str, NULL, 0, NULL,
 		     hdmi->default_bpp);
-
-	console_lock();
-
-	fb_destroy_modelist(&hdmi->fbi->modelist);
-
-	/*Add all no interlaced CEA mode to default modelist */
-	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
-		mode = &mxc_cea_mode[i];
-		if (mode->xres != 0) {
-			struct fb_videomode m = *mode;
-			m.flag |= FB_MODE_IS_STANDARD;
-			fb_add_videomode(&m, &hdmi->fbi->modelist);
-		}
-	}
-
-	console_unlock();
-
-	/* Find a nearest mode in default modelist */
 	fb_var_to_videomode(&m, &hdmi->fbi->var);
 	hdmi->dft_mode_set = false;
 
+	/* Find a nearest mode in default modelist */
 	mode = fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
 	if (!mode) {
 		pr_err("%s: could not find mode in modelist\n", __func__);
-- 
1.9.1


==============================================================
file 1111-video-mxc_hdmi-Consider-modes-that-differ-only-in-as.patch
==============================================================

From 9b245791da35efed7d3745ca5ca35d6cc73b49de Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Thu, 24 Dec 2015 08:44:50 +0100
Subject: [PATCH] video: mxc_hdmi: Consider modes that differ only in aspect
 ratio as duplicate

Certain CEA modes differ from each other only by the aspect ratio. If an EDID
indicates support for both modes of such an otherwise identical pair, we create
a mode list entry only for the first one. This is done because our sysfs cannot
distinguish them.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_hdmi.c | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index f71c1dd..182ae2a 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -1949,7 +1949,7 @@ static void mxc_hdmi_notify_fb(struct mxc_hdmi *hdmi, bool force_all)
 static void mxc_hdmi_create_modelist(struct mxc_hdmi *hdmi, int from_edid)
 {
 	struct fb_videomode mode;
-	int i, vic, mode_count = ARRAY_SIZE(mxc_cea_mode);
+	int i, j, skip, vic, mode_count = ARRAY_SIZE(mxc_cea_mode);
 	const struct fb_videomode *mode_data = mxc_cea_mode;
 
 	if (from_edid) {
@@ -1975,6 +1975,19 @@ static void mxc_hdmi_create_modelist(struct mxc_hdmi *hdmi, int from_edid)
 
 		mode = mode_data[i];
 
+		/* for dual aspect ratio modes, insert the first one only */
+		if (mode.vmode & FB_VMODE_ASPECT_MASK) {
+			skip = 0;
+			for (j = i - 1; !skip && j >= 0; j--) {
+				skip = mode.xres == mode_data[j].xres &&
+				       mode.yres == mode_data[j].yres &&
+				       mode.refresh == mode_data[j].refresh &&
+				       (mode.vmode ^ FB_VMODE_ASPECT_MASK) == mode_data[j].vmode;
+			}
+			if (skip)
+				continue;
+		}
+
 		/* TODO: Discuss if we should always set default modes as standard */
 		if (!from_edid /*&& ignore_edid*/)
 			mode.flag |= FB_MODE_IS_STANDARD;
-- 
1.9.1


==============================================================
file 1112-video-mxc_hdmi-Insert-standard-VGA-mode-only-once.patch
==============================================================

From 2e980a57c261407795511d4794c8d22e78ecb9b2 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Mon, 4 Jan 2016 08:41:22 +0100
Subject: [PATCH] video: mxc_hdmi: Insert standard VGA mode only once

Skip standard VGA if found in EDID. We force this mode to be present
by default and therefore should not add it a second time.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_hdmi.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 182ae2a..ec4a438 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -95,7 +95,7 @@
  * in HDMI Initialization Step B
  */
 static const struct fb_videomode vga_mode = {
-	/* 640x480 @ 60 Hz, 31.5 kHz hsync */
+	/* 640x480 @ 59.94 Hz, 31.5 kHz hsync */
 	NULL, 60, 640, 480, 39721, 48, 16, 33, 10, 96, 2, 0,
 	FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, FB_MODE_IS_VESA,
 };
@@ -1988,6 +1988,10 @@ static void mxc_hdmi_create_modelist(struct mxc_hdmi *hdmi, int from_edid)
 				continue;
 		}
 
+		/* Skip standard VGA (already present) */
+		if (vic == 1 && (mode.flag & FB_MODE_IS_VESA))
+			continue;
+
 		/* TODO: Discuss if we should always set default modes as standard */
 		if (!from_edid /*&& ignore_edid*/)
 			mode.flag |= FB_MODE_IS_STANDARD;
-- 
1.9.1


==============================================================
file 1113-video-mxc_hdmi-mxc_edid-Introduce-fractional-modes.patch
==============================================================

From 7df36826253b618c3d44d245b2f1e074112b91c3 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Thu, 24 Dec 2015 09:26:40 +0100
Subject: [PATCH] video: mxc_hdmi/mxc_edid: Introduce fractional modes

In order to support fractional refresh rates (23.976, 29.97, 59.94, 119.88Hz)
we create 'synthetic' modes. These have the same timing as the corresponding
non-fractional modes (i.e. 24, 30, 60 and 120Hz). However, the refresh rate
is set to 23, 29, 59 and 119, respectively. In addition they have the mode
bit FB_VMODE_FRACTIONAL set. This bit is taken in acount when calculating
the real pixel clock.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_edid.c | 15 ++++++++++-----
 drivers/video/mxc/mxc_hdmi.c | 25 +++++++++++++++++++++++--
 2 files changed, 33 insertions(+), 7 deletions(-)

diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index 1aaaa68..b3a6ee1 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -218,9 +218,9 @@ int mxc_edid_fb_mode_is_equal(bool use_aspect,
 	u32 mask;
 
 	if (use_aspect)
-		mask = ~0;
+		mask = ~FB_VMODE_FRACTIONAL;
 	else
-		mask = ~FB_VMODE_ASPECT_MASK;
+		mask = ~(FB_VMODE_FRACTIONAL | FB_VMODE_ASPECT_MASK);
 
 	return (mode1->xres         == mode2->xres &&
 		mode1->yres         == mode2->yres &&
@@ -823,7 +823,12 @@ const struct fb_videomode *mxc_fb_find_nearest_mode(const struct fb_videomode *m
 	struct fb_videomode *cmode;
 	static struct fb_videomode *best;
 	static u32 diff, diff_refresh;
-	u32 mask = relax ? FB_VMODE_MASK_SIMPLE | FB_VMODE_ASPECT_MASK : ~0;
+	u32 mask = relax ? ~FB_VMODE_ASPECT_MASK : ~0;
+	int refresh = mode->refresh;
+
+	if ((mode->flag & FB_MODE_IS_FROM_VAR) &&
+	    (mode->vmode & FB_VMODE_FRACTIONAL))
+		refresh--;
 
 	if (!relax) {
 		diff = -1;
@@ -844,10 +849,10 @@ const struct fb_videomode *mxc_fb_find_nearest_mode(const struct fb_videomode *m
 			abs(cmode->yres - mode->yres);
 		if (diff > d) {
 			diff = d;
-			diff_refresh = abs(cmode->refresh - mode->refresh);
+			diff_refresh = abs(cmode->refresh - refresh);
 			best = cmode;
 		} else if (diff == d) {
-			d = abs(cmode->refresh - mode->refresh);
+			d = abs(cmode->refresh - refresh);
 			if (diff_refresh > d) {
 				diff_refresh = d;
 				best = cmode;
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index ec4a438..6156e16 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -1999,9 +1999,30 @@ static void mxc_hdmi_create_modelist(struct mxc_hdmi *hdmi, int from_edid)
 		if (fb_add_videomode(&mode, &hdmi->fbi->modelist))
 			continue;
 
-		dev_dbg(&hdmi->pdev->dev, "Added mode: %d, vic: %d", i, vic);
 		dev_dbg(&hdmi->pdev->dev,
-			"xres = %d, yres = %d, scan = %c, ratio = %s, freq = %d, vmode = %d, flag = %d\n",
+			"Mode: vic=%d, xres=%d, yres=%d, scan=%c, ratio=%s, freq=%d, vmode=%d, flag=%d\n",
+			vic,
+			mode.xres,
+			mode.yres,
+			mode.vmode & FB_VMODE_INTERLACED ? 'i' : 'p',
+			mode.vmode & FB_VMODE_ASPECT_4_3 ? "4/3" :
+			    mode.vmode & FB_VMODE_ASPECT_16_9 ? "16/9" : "n/a",
+			mode.refresh,
+			mode.vmode,
+			mode.flag);
+
+		/* check if fractional mode should be inserted */
+		if (vic == 0 || !(mode.refresh == 24 || (mode.refresh % 30) == 0))
+			continue;
+
+		mode.refresh--;
+		mode.vmode |= FB_VMODE_FRACTIONAL;
+		if (fb_add_videomode(&mode, &hdmi->fbi->modelist))
+			continue;
+
+		dev_dbg(&hdmi->pdev->dev,
+			"Mode: vic=%d, xres=%d, yres=%d, scan=%c, ratio=%s, freq=%d, vmode=%d, flag=%d\n",
+			vic,
 			mode.xres,
 			mode.yres,
 			mode.vmode & FB_VMODE_INTERLACED ? 'i' : 'p',
-- 
1.9.1


==============================================================
file 1114-video-mxc_edid-Adjust-pixel-timings.patch
==============================================================

From cec6f4f51f22cd0324f255cb99a85eaa7f3d0d78 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Thu, 24 Dec 2015 09:51:31 +0100
Subject: [PATCH] video: mxc_edid: Adjust pixel timings

Our approach for fractional mode support requires the pixel timings
in the CEA mode table to describe the non-fractional modes. This
patch sets this for the modes that were defined otherwise.
Also it tweaks the rounding when calculating the real pixel clock
from the pixel time specified in the table.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_edid.c | 19 ++++++++++++-------
 include/video/mxc_edid.h     |  4 ++--
 2 files changed, 14 insertions(+), 9 deletions(-)

diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index b3a6ee1..edfd6e8 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -38,20 +38,25 @@
 #define DPRINTK(fmt, args...)
 #endif
 
+/*
+ * Attention:	pixel times for the fractional mode entries must
+ *		specify the non-fractional frequency of that mode!
+ *		I.e. 60Hz instead of 59.94 and 24Hz instead of 23.98.
+ */
 const struct fb_videomode mxc_cea_mode[64] = {
 	/* #1: 640x480p@59.94/60Hz 4:3 */
 	[1] = {
-		NULL, 60, 640, 480, 39722, 48, 16, 33, 10, 96, 2, 0,
+		NULL, 60, 640, 480, 39682, 48, 16, 33, 10, 96, 2, 0,
 		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
 	},
 	/* #2: 720x480p@59.94/60Hz 4:3 */
 	[2] = {
-		NULL, 60, 720, 480, 37037, 60, 16, 30, 9, 62, 6, 0,
+		NULL, 60, 720, 480, 37000, 60, 16, 30, 9, 62, 6, 0,
 		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
 	},
 	/* #3: 720x480p@59.94/60Hz 16:9 */
 	[3] = {
-		NULL, 60, 720, 480, 37037, 60, 16, 30, 9, 62, 6, 0,
+		NULL, 60, 720, 480, 37000, 60, 16, 30, 9, 62, 6, 0,
 		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
 	/* #4: 1280x720p@59.94/60Hz 16:9 */
@@ -68,22 +73,22 @@ const struct fb_videomode mxc_cea_mode[64] = {
 	},
 	/* #6: 720(1440)x480iH@59.94/60Hz 4:3 */
 	[6] = {
-		NULL, 60, 1440, 480, 37037, 38, 114, 8, 31, 124, 6, 0,
+		NULL, 60, 1440, 480, 37000, 38, 114, 8, 31, 124, 6, 0,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3, 0,
 	},
 	/* #7: 720(1440)x480iH@59.94/60Hz 16:9 */
 	[7] = {
-		NULL, 60, 1440, 480, 37037, 38, 114, 8, 31, 124, 6, 0,
+		NULL, 60, 1440, 480, 37000, 38, 114, 8, 31, 124, 6, 0,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
 	/* #8: 720(1440)x240pH@59.94/60Hz 4:3 */
 	[8] = {
-		NULL, 60, 1440, 240, 37108, 114, 38, 15, 4, 124, 3, 0,
+		NULL, 60, 1440, 240, 37000, 114, 38, 15, 4, 124, 3, 0,
 		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
 	},
 	/* #9: 720(1440)x240pH@59.94/60Hz 16:9 */
 	[9] = {
-		NULL, 60, 1440, 240, 37108, 114, 38, 15, 4, 124, 3, 0,
+		NULL, 60, 1440, 240, 37000, 114, 38, 15, 4, 124, 3, 0,
 		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
 	/* #14: 1440x480p@59.94/60Hz 4:3 */
diff --git a/include/video/mxc_edid.h b/include/video/mxc_edid.h
index 561fe61..2feed16 100644
--- a/include/video/mxc_edid.h
+++ b/include/video/mxc_edid.h
@@ -100,8 +100,8 @@ struct mxc_edid_cfg {
 };
 
 static inline unsigned long mxcPICOS2KHZ(u32 pixclock, u32 vmode) {
-	u32 x = (1000000000UL / (pixclock) * 1000 / ((vmode & FB_VMODE_FRACTIONAL) ? 1001 : 1000));
-	return x + ((1000000000UL % x) > (x / 2) ? 1 : 0);
+	return ((((vmode & FB_VMODE_FRACTIONAL) ?
+			(999000999UL*4) : (1000000000UL*4)) / pixclock) + 1) >> 2;
 }
 
 int mxc_edid_var_to_vic(struct fb_var_screeninfo *var);
-- 
1.9.1


==============================================================
file 1115-video-mxc_ipuv3_fb-Adjust-IPU-pixelclock.patch
==============================================================

From 8b308a05dbfdbdffaf632857bc70a6005f95a6f5 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Tue, 29 Dec 2015 17:13:54 +0100
Subject: [PATCH] video: mxc_ipuv3_fb: Adjust IPU pixelclock

Use 'fractional' pixelclock calculation for IPU as well.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_ipuv3_fb.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/drivers/video/mxc/mxc_ipuv3_fb.c b/drivers/video/mxc/mxc_ipuv3_fb.c
index 9a3764f..8856c32 100644
--- a/drivers/video/mxc/mxc_ipuv3_fb.c
+++ b/drivers/video/mxc/mxc_ipuv3_fb.c
@@ -49,6 +49,7 @@
 #include <linux/string.h>
 #include <linux/uaccess.h>
 
+#include <video/mxc_edid.h>
 #include "mxc_dispdrv.h"
 
 /*
@@ -643,11 +644,11 @@ static int mxcfb_set_par(struct fb_info *fbi)
 		if (fbi->var.sync & FB_SYNC_CLK_IDLE_EN)
 			sig_cfg.clkidle_en = true;
 
-		dev_dbg(fbi->device, "pixclock = %ul Hz\n",
-			(u32) (PICOS2KHZ(fbi->var.pixclock) * 1000UL));
+		dev_dbg(fbi->device, "pixclock = %lu Hz\n",
+			mxcPICOS2KHZ(fbi->var.pixclock, fbi->var.vmode) * 1000UL);
 
 		if (ipu_init_sync_panel(mxc_fbi->ipu, mxc_fbi->ipu_di,
-					(PICOS2KHZ(fbi->var.pixclock)) * 1000UL,
+					(mxcPICOS2KHZ(fbi->var.pixclock, fbi->var.vmode)) * 1000UL,
 					fbi->var.xres, fbi->var.yres,
 					out_pixel_fmt,
 					fbi->var.left_margin,
-- 
1.9.1


==============================================================
file 1116-video-mxc-hdmi-core-Allow-cts-n-lookup-frequencies-t.patch
==============================================================

From bb45ab9854fa0a594fe5deb694000ad4e45497bd Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Thu, 24 Dec 2015 10:01:00 +0100
Subject: [PATCH] video: mxc-hdmi-core: Allow cts/n lookup frequencies to be
 off by one

Due to rounding errors it may happen that the calculated pixel clock does
not exactly match the frequency listed in the lookup table. Modes known
to show this problem are 29 and 30 (1440x576p-50). This patch relaxes the
lookup so that a difference of 1kHz will be tolerated.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/mfd/mxc-hdmi-core.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/mfd/mxc-hdmi-core.c b/drivers/mfd/mxc-hdmi-core.c
index 4fbd315..a7be3cd 100644
--- a/drivers/mfd/mxc-hdmi-core.c
+++ b/drivers/mfd/mxc-hdmi-core.c
@@ -441,8 +441,8 @@ static bool hdmi_compute_cts_n(unsigned int freq, unsigned long pixel_clk,
 static void hdmi_lookup_cts_n(unsigned int freq, unsigned long pixel_clk,
 				   unsigned int *n, unsigned int *cts)
 {
-	unsigned int clk = pixel_clk / 1000;
-	unsigned int frq = freq;
+	int clk = pixel_clk / 1000;
+	int frq = freq;
 	int i, j;
 
 	*n = 1;
@@ -468,7 +468,7 @@ static void hdmi_lookup_cts_n(unsigned int freq, unsigned long pixel_clk,
 	}
 
 	for (i = 0; i < ARRAY_SIZE(mxc_hdmi_ctsn_tbl); i++) {
-		if (mxc_hdmi_ctsn_tbl[i].pixclk == clk) {
+		if (abs(mxc_hdmi_ctsn_tbl[i].pixclk - clk) <= 1) {
 			for (j = 0; j < 3; j++) {
 				if (mxc_hdmi_ctsn_tbl[i].ctsn[j].freq == frq) {
 					*n *= mxc_hdmi_ctsn_tbl[i].ctsn[j].n;
-- 
1.9.1


==============================================================
file 1117-video-mxc_edid-Cleanup-and-remove-unused-function.patch
==============================================================

From f08f0fa19625721778ff8685908e81e589df543e Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Fri, 25 Dec 2015 09:06:46 +0100
Subject: [PATCH] video: mxc_edid: Cleanup and remove unused function

mxc_edid_var_to_vic() is exported but never used. Let's get rid of it. Also
streamline mxc_edid_mode_to_vic() a bit and make mxc_edid_fb_mode_is_equal()
static.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_edid.c | 27 +++------------------------
 include/video/mxc_edid.h     |  1 -
 2 files changed, 3 insertions(+), 25 deletions(-)

diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index edfd6e8..ef8d261 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -216,7 +216,7 @@ EXPORT_SYMBOL(mxc_fb_mode_is_equal_res);
  * pixclock, since for many CEA modes, 2 frequencies are supported
  * e.g. 640x480 @ 60Hz or 59.94Hz
  */
-int mxc_edid_fb_mode_is_equal(bool use_aspect,
+static int mxc_edid_fb_mode_is_equal(bool use_aspect,
 			const struct fb_videomode *mode1,
 			const struct fb_videomode *mode2)
 {
@@ -741,24 +741,6 @@ static int mxc_edid_readsegblk(struct i2c_adapter *adp, unsigned short addr,
 	return ret;
 }
 
-int mxc_edid_var_to_vic(struct fb_var_screeninfo *var)
-{
-	int i;
-	struct fb_videomode m;
-
-	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
-		fb_var_to_videomode(&m, var);
-		if (mxc_edid_fb_mode_is_equal(false, &m, &mxc_cea_mode[i]))
-			break;
-	}
-
-	if (i == ARRAY_SIZE(mxc_cea_mode))
-		return 0;
-
-	return i;
-}
-EXPORT_SYMBOL(mxc_edid_var_to_vic);
-
 int mxc_edid_mode_to_vic(const struct fb_videomode *mode)
 {
 	int i;
@@ -766,13 +748,10 @@ int mxc_edid_mode_to_vic(const struct fb_videomode *mode)
 
 	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
 		if (mxc_edid_fb_mode_is_equal(use_aspect, mode, &mxc_cea_mode[i]))
-			break;
+			return i;
 	}
 
-	if (i == ARRAY_SIZE(mxc_cea_mode))
-		return 0;
-
-	return i;
+	return 0;
 }
 EXPORT_SYMBOL(mxc_edid_mode_to_vic);
 
diff --git a/include/video/mxc_edid.h b/include/video/mxc_edid.h
index 2feed16..1e89fd2 100644
--- a/include/video/mxc_edid.h
+++ b/include/video/mxc_edid.h
@@ -104,7 +104,6 @@ static inline unsigned long mxcPICOS2KHZ(u32 pixclock, u32 vmode) {
 			(999000999UL*4) : (1000000000UL*4)) / pixclock) + 1) >> 2;
 }
 
-int mxc_edid_var_to_vic(struct fb_var_screeninfo *var);
 int mxc_edid_mode_to_vic(const struct fb_videomode *mode);
 int mxc_edid_read(struct i2c_adapter *adp, unsigned short addr,
 	unsigned char *edid, struct mxc_edid_cfg *cfg, struct fb_info *fbi);
-- 
1.9.1


==============================================================
file 1118-video-mxc_edid-Change-nearest-mode-search.patch
==============================================================

From 7b18488d08056d75da96615319d3a46df98ce0ae Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Fri, 25 Dec 2015 17:12:19 +0100
Subject: [PATCH] video: mxc_edid: Change nearest mode search

The mode match is now performed in up to four passes:
1.) Include modes with exactly the same vmode
2.) Include modes ignoring aspect ratio flags
3.) Include modes with opposite scan but otherwise same vmode
4.) Include modes with opposite scan ignoring aspect ratio flags

The flag FB_VMODE_FRACTIONAL is always ignored.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_edid.c | 63 ++++++++++++++++++++++----------------------
 drivers/video/mxc/mxc_hdmi.c |  4 +--
 include/video/mxc_edid.h     |  2 +-
 3 files changed, 34 insertions(+), 35 deletions(-)

diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index ef8d261..87bd119 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -800,52 +800,51 @@ int mxc_edid_read(struct i2c_adapter *adp, unsigned short addr,
 EXPORT_SYMBOL(mxc_edid_read);
 
 const struct fb_videomode *mxc_fb_find_nearest_mode(const struct fb_videomode *mode,
-						    struct list_head *head, bool relax)
+					  struct list_head *head)
 {
 	struct list_head *pos;
 	struct fb_modelist *modelist;
 	struct fb_videomode *cmode;
-	static struct fb_videomode *best;
-	static u32 diff, diff_refresh;
-	u32 mask = relax ? ~FB_VMODE_ASPECT_MASK : ~0;
-	int refresh = mode->refresh;
+	struct fb_videomode *best = NULL;
+	u32 d, diff = ~0, diff_refresh = ~0;
+	int i, refresh = mode->refresh;
+	static const u32 masks[] = {
+		~(FB_VMODE_FRACTIONAL),
+		~(FB_VMODE_FRACTIONAL | FB_VMODE_ASPECT_MASK),
+		~(FB_VMODE_FRACTIONAL | FB_VMODE_INTERLACED),
+		~(FB_VMODE_FRACTIONAL | FB_VMODE_INTERLACED | FB_VMODE_ASPECT_MASK)
+	};
 
 	if ((mode->flag & FB_MODE_IS_FROM_VAR) &&
 	    (mode->vmode & FB_VMODE_FRACTIONAL))
 		refresh--;
 
-	if (!relax) {
-		diff = -1;
-		diff_refresh = -1;
-		best = NULL;
-	}
+	for (i = 0; i < ARRAY_SIZE(masks); i++) {
+		list_for_each(pos, head) {
+			modelist = list_entry(pos, struct fb_modelist, list);
+			cmode = &modelist->mode;
+
+			if ((mode->vmode ^ cmode->vmode) & masks[i])
+					continue;
 
-	list_for_each(pos, head) {
-		u32 d;
-
-		modelist = list_entry(pos, struct fb_modelist, list);
-		cmode = &modelist->mode;
-
-		if ((mode->vmode ^ cmode->vmode) & mask)
-				continue;
-
-		d = abs(cmode->xres - mode->xres) +
-			abs(cmode->yres - mode->yres);
-		if (diff > d) {
-			diff = d;
-			diff_refresh = abs(cmode->refresh - refresh);
-			best = cmode;
-		} else if (diff == d) {
-			d = abs(cmode->refresh - refresh);
-			if (diff_refresh > d) {
-				diff_refresh = d;
+			d = abs(cmode->xres - mode->xres) +
+				abs(cmode->yres - mode->yres);
+			if (diff > d) {
+				diff = d;
+				diff_refresh = abs(cmode->refresh - refresh);
 				best = cmode;
+			} else if (diff == d) {
+				d = abs(cmode->refresh - refresh);
+				if (diff_refresh > d) {
+					diff_refresh = d;
+					best = cmode;
+				}
 			}
 		}
-	}
 
-	if ((!relax && (diff_refresh || diff)) || !best)
-		mxc_fb_find_nearest_mode(mode, head, true);
+		if (diff_refresh == 0 && diff == 0)
+			break;
+	}
 
 	return best;
 }
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 6156e16..6baf1b6 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -2072,7 +2072,7 @@ static void mxc_hdmi_set_mode(struct mxc_hdmi *hdmi, int edid_status)
 
 	fb_var_to_videomode(&m, &var);
 	dump_fb_videomode(&m);
-	mode = mxc_fb_find_nearest_mode(&m, &hdmi->fbi->modelist, false);
+	mode = mxc_fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
 
 	if (mode) {
 		hdmi->fbi->mode = (struct fb_videomode *)mode;
@@ -2378,7 +2378,7 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 		else
 			memset(&hdmi->prev_virtual, 0, sizeof(hdmi->prev_virtual));
 		if (!list_empty(&hdmi->fbi->modelist)) {
-			edid_mode = mxc_fb_find_nearest_mode(&m, &hdmi->fbi->modelist, false);
+			edid_mode = mxc_fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
 			pr_debug("edid mode ");
 			/* update fbi mode */
 			hdmi->fbi->mode = (struct fb_videomode *)edid_mode;
diff --git a/include/video/mxc_edid.h b/include/video/mxc_edid.h
index 1e89fd2..01a487e 100644
--- a/include/video/mxc_edid.h
+++ b/include/video/mxc_edid.h
@@ -110,6 +110,6 @@ int mxc_edid_read(struct i2c_adapter *adp, unsigned short addr,
 int mxc_edid_parse_ext_blk(unsigned char *edid, struct mxc_edid_cfg *cfg,
 	struct fb_monspecs *specs);
 const struct fb_videomode *mxc_fb_find_nearest_mode(const struct fb_videomode *mode,
-                                                    struct list_head *head, bool relax);
+						struct list_head *head);
 int mxc_fb_mode_is_equal_res(const struct fb_videomode *mode1, const struct fb_videomode *mode2);
 #endif
-- 
1.9.1


==============================================================
file 1119-video-mxc_hdmi-Improve-initial-mode-setup.patch
==============================================================

From 895b9c2629e2267a1b89ddfa8eedc9349a4fa397 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Tue, 5 Jan 2016 13:21:46 +0100
Subject: [PATCH] video: mxc_hdmi: Improve initial mode setup

Use mxc_fb_find_nearest_mode() for parsing the mode specified on kernel
command line. This makes sure that the interlaced flag is honoured. Use
standard VGA in case the command line argument cannot be parsed.

Also adapt to the fact, that the fb_var_screeninfo returned fb_find_mode()
has it's refresh rate doubled for interlaced modes.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_hdmi.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 6baf1b6..620168a 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -2819,13 +2819,15 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 
 	/* Set the default mode when disp init. */
 	fb_find_mode(&hdmi->fbi->var, hdmi->fbi,
-		     hdmi->dft_mode_str, NULL, 0, NULL,
-		     hdmi->default_bpp);
+		     hdmi->dft_mode_str, NULL, 0,
+		     &vga_mode, hdmi->default_bpp);
 	fb_var_to_videomode(&m, &hdmi->fbi->var);
+	if (m.vmode & FB_VMODE_INTERLACED)
+		m.refresh = (m.refresh / 2) - 2;
 	hdmi->dft_mode_set = false;
 
 	/* Find a nearest mode in default modelist */
-	mode = fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
+	mode = mxc_fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
 	if (!mode) {
 		pr_err("%s: could not find mode in modelist\n", __func__);
 		return -1;
-- 
1.9.1


==============================================================
file 1120-video-mxc_edid-mxc_hdmi-Remove-mxc_fb_mode_is_equal_.patch
==============================================================

From 28ff0ad3abf468a7927737a182599472f5a4e8d7 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Sat, 26 Dec 2015 19:09:59 +0100
Subject: [PATCH] video: mxc_edid/mxc_hdmi: Remove mxc_fb_mode_is_equal_res()

Checking for equal resolutions doesn't require a dedicated function.
Especially if this function doesn't quite do what the name suggests.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_edid.c | 13 -------------
 drivers/video/mxc/mxc_hdmi.c | 18 ++++++++++--------
 include/video/mxc_edid.h     |  1 -
 3 files changed, 10 insertions(+), 22 deletions(-)

diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index 87bd119..aa6d24f 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -197,19 +197,6 @@ const struct fb_videomode mxc_cea_mode[64] = {
 	},
 };
 
-#define FB_VMODE_MASK_SIMPLE (FB_VMODE_NONINTERLACED | FB_VMODE_INTERLACED | \
-			      FB_VMODE_FRACTIONAL    | FB_VMODE_ASPECT_MASK)
-
-int mxc_fb_mode_is_equal_res(const struct fb_videomode *mode1,
-			     const struct fb_videomode *mode2)
-{
-	return (mode1->xres         == mode2->xres &&
-		mode1->yres         == mode2->yres &&
-		mode1->refresh      == mode2->refresh &&
-		(mode1->vmode & FB_VMODE_MASK_SIMPLE) ==
-		(mode2->vmode & FB_VMODE_MASK_SIMPLE));
-}
-EXPORT_SYMBOL(mxc_fb_mode_is_equal_res);
 
 /*
  * We have a special version of fb_mode_is_equal that ignores
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 620168a..170704d 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -2074,23 +2074,24 @@ static void mxc_hdmi_set_mode(struct mxc_hdmi *hdmi, int edid_status)
 	dump_fb_videomode(&m);
 	mode = mxc_fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
 
-	if (mode) {
-		hdmi->fbi->mode = (struct fb_videomode *)mode;
-		fb_videomode_to_var(&hdmi->fbi->var, mode);
-	} else {
+	if (!mode) {
 		pr_err("%s: could not find mode in modelist\n", __func__);
 		return;
 	}
 
+	hdmi->fbi->mode = (struct fb_videomode *)mode;
+	fb_videomode_to_var(&hdmi->fbi->var, mode);
+
 	/* restore xBuffer if dimension match */
-	if ((edid_status == HDMI_EDID_SAME && fb_mode_is_equal(&hdmi->previous_non_vga_mode, mode)) ||
-	    (edid_status != HDMI_EDID_SAME && mxc_fb_mode_is_equal_res(&hdmi->previous_non_vga_mode, mode))) {
+	if (hdmi->previous_non_vga_mode.xres == mode->xres &&
+	    hdmi->previous_non_vga_mode.yres == mode->yres) {
 		dev_dbg(&hdmi->pdev->dev,
-				"%s: Video mode %ssame as previous\n", __func__, edid_status == HDMI_EDID_SAME ? "+ EDID " : "");
+			"%s: Resolution %ssame as previous\n",
+			__func__, edid_status == HDMI_EDID_SAME ? "+ EDID " : "");
 		if (hdmi->prev_virtual.xres_virtual)
 			memcpy(&hdmi->fbi->var.xres_virtual, &hdmi->prev_virtual, sizeof(hdmi->prev_virtual));
 	} else {
-		dev_dbg(&hdmi->pdev->dev, "%s: New video mode\n", __func__);
+		dev_dbg(&hdmi->pdev->dev, "%s: Resolution changed\n", __func__);
 		new_screen = true;
 	}
 
@@ -2377,6 +2378,7 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 			memcpy(&hdmi->prev_virtual, &hdmi->fbi->var.xres_virtual, sizeof(hdmi->prev_virtual));
 		else
 			memset(&hdmi->prev_virtual, 0, sizeof(hdmi->prev_virtual));
+
 		if (!list_empty(&hdmi->fbi->modelist)) {
 			edid_mode = mxc_fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
 			pr_debug("edid mode ");
diff --git a/include/video/mxc_edid.h b/include/video/mxc_edid.h
index 01a487e..f00d142 100644
--- a/include/video/mxc_edid.h
+++ b/include/video/mxc_edid.h
@@ -111,5 +111,4 @@ int mxc_edid_parse_ext_blk(unsigned char *edid, struct mxc_edid_cfg *cfg,
 	struct fb_monspecs *specs);
 const struct fb_videomode *mxc_fb_find_nearest_mode(const struct fb_videomode *mode,
 						struct list_head *head);
-int mxc_fb_mode_is_equal_res(const struct fb_videomode *mode1, const struct fb_videomode *mode2);
 #endif
-- 
1.9.1


==============================================================
file 1121-video-mxc_hdmi-Simplify-aspect-ratio-setup-for-AVI-i.patch
==============================================================

From 8f6db7a2663ab2cfb50569b1ea74e02395703245 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Sat, 26 Dec 2015 19:15:55 +0100
Subject: [PATCH] video: mxc_hdmi: Simplify aspect ratio setup for AVI
 infoframe

Either use the aspect ratio flags already present in fb_videomode
or calulate them from current resolution.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_hdmi.c | 18 +++++++-----------
 1 file changed, 7 insertions(+), 11 deletions(-)

diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 170704d..e5d6bc5 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -1418,21 +1418,17 @@ static void hdmi_config_AVI(struct mxc_hdmi *hdmi)
 	u8 under_scan;
 	u8 act_ratio, coded_ratio, colorimetry, ext_colorimetry;
 	struct fb_videomode mode;
-	const struct fb_videomode *edid_mode;
-	bool aspect_16_9;
 
 	dev_dbg(&hdmi->pdev->dev, "set up AVI frame\n");
 
 	fb_var_to_videomode(&mode, &hdmi->fbi->var);
-	/* Use mode from list extracted from EDID to get aspect ratio */
-	if (!list_empty(&hdmi->fbi->modelist)) {
-		edid_mode = fb_find_nearest_mode(&mode, &hdmi->fbi->modelist);
-		if (edid_mode->vmode & FB_VMODE_ASPECT_16_9)
-			aspect_16_9 = true;
+
+	if (!(mode.vmode & FB_VMODE_ASPECT_MASK)) {
+		if( mode.xres <= (mode.yres / 3) * 4)
+			mode.vmode |= FB_VMODE_ASPECT_4_3;
 		else
-			aspect_16_9 = false;
-	} else
-		aspect_16_9 = false;
+			mode.vmode |= FB_VMODE_ASPECT_16_9;
+	}
 
 	/********************************************
 	 * AVI Data Byte 1
@@ -1464,7 +1460,7 @@ static void hdmi_config_AVI(struct mxc_hdmi *hdmi)
 	 ********************************************/
 
 	/*  Set the Aspect Ratio */
-	if (aspect_16_9) {
+	if (mode.vmode & FB_VMODE_ASPECT_16_9) {
 		act_ratio = HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_16_9;
 		coded_ratio = HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_16_9;
 	} else {
-- 
1.9.1


==============================================================
file 1122-video-mxc_hdmi-Adjust-pixel-repetition-setup-for-AVI.patch
==============================================================

From 6468baf32d804c9d79a5260699a69bfb9f586d31 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Sun, 27 Dec 2015 10:37:39 +0100
Subject: [PATCH] video: mxc_hdmi: Adjust pixel repetition setup for AVI
 infoframe

Fix the pixel repetition field in AVI info frame. For VIC 14,15,29
and 30 we set the factor to 1 so that the output width matches the
frame buffer width (i.e. 1440). Also we fill in the correct value
for modes that imply the usage of repetition factor 2.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_hdmi.c | 30 +++++++++++++++++++++---------
 1 file changed, 21 insertions(+), 9 deletions(-)

diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index e5d6bc5..42e7e06 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -2406,17 +2406,29 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 	else
 		hdmi->hdmi_data.colorimetry = eITU709;
 
-	if ((hdmi->vic == 10) || (hdmi->vic == 11) ||
-		(hdmi->vic == 12) || (hdmi->vic == 13) ||
-		(hdmi->vic == 14) || (hdmi->vic == 15) ||
-		(hdmi->vic == 25) || (hdmi->vic == 26) ||
-		(hdmi->vic == 27) || (hdmi->vic == 28) ||
-		(hdmi->vic == 29) || (hdmi->vic == 30) ||
-		(hdmi->vic == 35) || (hdmi->vic == 36) ||
-		(hdmi->vic == 37) || (hdmi->vic == 38))
+	if ((hdmi->vic >= 6 && hdmi->vic <= 9) ||
+		(hdmi->vic >= 21 && hdmi->vic <= 24) ||
+		(hdmi->vic >= 44 && hdmi->vic <= 45) ||
+		(hdmi->vic >= 50 && hdmi->vic <= 51) ||
+		(hdmi->vic >= 55 && hdmi->vic <= 56) ||
+		(hdmi->vic >= 58 && hdmi->vic <= 59) ) {
+		/* These formats require a pixel repetition factor of 2 */
 		hdmi->hdmi_data.video_mode.mPixelRepetitionOutput = 1;
-	else
+	} else if ((hdmi->vic >= 14 && hdmi->vic <= 15) ||
+		(hdmi->vic >= 29 && hdmi->vic <= 30) ) {
+		/* These formats may be used with repetition factors 1 or 2 */
+		/* We use 1 to select picture a width of 1440 (vs. 720) */
+		hdmi->hdmi_data.video_mode.mPixelRepetitionOutput = 0;
+	} else if ((hdmi->vic >= 10 && hdmi->vic <= 13) ||
+		(hdmi->vic >= 25 && hdmi->vic <= 28) ||
+		(hdmi->vic >= 35 && hdmi->vic <= 38)) {
+		/* These formats may be used with multiple repetition factors */
+		/* The width for factor == 1 is 2880 (currently unsupported) */
+		hdmi->hdmi_data.video_mode.mPixelRepetitionOutput = 3;
+	} else {
+		/* No repetition (i.e. factor 1) */
 		hdmi->hdmi_data.video_mode.mPixelRepetitionOutput = 0;
+	}
 
 	hdmi->hdmi_data.video_mode.mPixelRepetitionInput = 0;
 
-- 
1.9.1


==============================================================
file 1123-video-mxc_hdmi-mxc_edid-Prepare-for-double-clock-mod.patch
==============================================================

From 604a8ed3318f9ce0cd952c7c222dc11bd38f0829 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Tue, 29 Dec 2015 09:57:04 +0100
Subject: [PATCH] video: mxc_hdmi/mxc_edid: Prepare for double-clock modes

Certain low resolution modes require double clocking in order meet
the minimum speed requirements of the interface. This patch prepares
support for those, but keeps them disabled.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_edid.c | 93 +++++++++++++++++++++++++++++++-------------
 drivers/video/mxc/mxc_hdmi.c | 14 ++++---
 include/video/mxc_edid.h     |  2 +
 3 files changed, 76 insertions(+), 33 deletions(-)

diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index aa6d24f..3baac3c 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -73,23 +73,23 @@ const struct fb_videomode mxc_cea_mode[64] = {
 	},
 	/* #6: 720(1440)x480iH@59.94/60Hz 4:3 */
 	[6] = {
-		NULL, 60, 1440, 480, 37000, 38, 114, 8, 31, 124, 6, 0,
-		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3, 0,
+		NULL, 60, 720, 480, 37000, 38, 114, 8, 31, 124, 6, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3 | FB_VMODE_DBLCLK, 0,
 	},
 	/* #7: 720(1440)x480iH@59.94/60Hz 16:9 */
 	[7] = {
-		NULL, 60, 1440, 480, 37000, 38, 114, 8, 31, 124, 6, 0,
-		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+		NULL, 60, 720, 480, 37000, 38, 114, 8, 31, 124, 6, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9 | FB_VMODE_DBLCLK, 0,
 	},
 	/* #8: 720(1440)x240pH@59.94/60Hz 4:3 */
 	[8] = {
-		NULL, 60, 1440, 240, 37000, 114, 38, 15, 4, 124, 3, 0,
-		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+		NULL, 60, 720, 240, 37000, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3 | FB_VMODE_DBLCLK, 0,
 	},
 	/* #9: 720(1440)x240pH@59.94/60Hz 16:9 */
 	[9] = {
-		NULL, 60, 1440, 240, 37000, 114, 38, 15, 4, 124, 3, 0,
-		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+		NULL, 60, 720, 240, 37000, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9 | FB_VMODE_DBLCLK, 0,
 	},
 	/* #14: 1440x480p@59.94/60Hz 4:3 */
 	[14] = {
@@ -131,30 +131,30 @@ const struct fb_videomode mxc_cea_mode[64] = {
 	},
 	/* #21: 720(1440)x576i@50Hz */
 	[21] = {
-		NULL, 50, 1440, 576, 37037, 24, 138, 4, 39, 126, 6, 0,
-		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3, 0,
+		NULL, 50, 720, 576, 37037, 24, 138, 4, 39, 126, 6, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3 | FB_VMODE_DBLCLK, 0,
 	},
 	/* #22: 720(1440)x576i@50Hz */
 	[22] = {
-		NULL, 50, 1440, 576, 37037, 24, 138, 4, 39, 126, 6, 0,
-		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+		NULL, 50, 720, 576, 37037, 24, 138, 4, 39, 126, 6, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9 | FB_VMODE_DBLCLK, 0,
 	},
 	/* #23: 720(1440)x288pH@50Hz 4:3 */
 	[23] = {
-		NULL, 50, 1440, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
-		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+		NULL, 50, 720, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3 | FB_VMODE_DBLCLK, 0,
 	},
 	/* #24: 720(1440)x288pH@50Hz 16:9 */
 	[24] = {
-		NULL, 50, 1440, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
-		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+		NULL, 50, 720, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9 | FB_VMODE_DBLCLK, 0,
 	},
-	/* #29: 720(1440)x576pH@50Hz 4:3 */
+	/* #29: 1440x576p@50Hz 4:3 */
 	[29] = {
 		NULL, 50, 1440, 576, 18518, 136, 24, 39, 5, 128, 5, 0,
 		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
 	},
-	/* #30: 720(1440)x576pH@50Hz 16:9 */
+	/* #30: 1440x576p@50Hz 16:9 */
 	[30] = {
 		NULL, 50, 1440, 576, 18518, 136, 24, 39, 5, 128, 5, 0,
 		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
@@ -210,9 +210,9 @@ static int mxc_edid_fb_mode_is_equal(bool use_aspect,
 	u32 mask;
 
 	if (use_aspect)
-		mask = ~FB_VMODE_FRACTIONAL;
+		mask = ~(FB_VMODE_FRACTIONAL | FB_VMODE_DBLCLK);
 	else
-		mask = ~(FB_VMODE_FRACTIONAL | FB_VMODE_ASPECT_MASK);
+		mask = ~(FB_VMODE_FRACTIONAL | FB_VMODE_DBLCLK | FB_VMODE_ASPECT_MASK);
 
 	return (mode1->xres         == mode2->xres &&
 		mode1->yres         == mode2->yres &&
@@ -796,16 +796,12 @@ const struct fb_videomode *mxc_fb_find_nearest_mode(const struct fb_videomode *m
 	u32 d, diff = ~0, diff_refresh = ~0;
 	int i, refresh = mode->refresh;
 	static const u32 masks[] = {
-		~(FB_VMODE_FRACTIONAL),
-		~(FB_VMODE_FRACTIONAL | FB_VMODE_ASPECT_MASK),
-		~(FB_VMODE_FRACTIONAL | FB_VMODE_INTERLACED),
-		~(FB_VMODE_FRACTIONAL | FB_VMODE_INTERLACED | FB_VMODE_ASPECT_MASK)
+		~(FB_VMODE_FRACTIONAL | FB_VMODE_DBLCLK),
+		~(FB_VMODE_FRACTIONAL | FB_VMODE_DBLCLK | FB_VMODE_ASPECT_MASK),
+		~(FB_VMODE_FRACTIONAL | FB_VMODE_DBLCLK | FB_VMODE_INTERLACED),
+		~(FB_VMODE_FRACTIONAL | FB_VMODE_DBLCLK | FB_VMODE_INTERLACED | FB_VMODE_ASPECT_MASK)
 	};
 
-	if ((mode->flag & FB_MODE_IS_FROM_VAR) &&
-	    (mode->vmode & FB_VMODE_FRACTIONAL))
-		refresh--;
-
 	for (i = 0; i < ARRAY_SIZE(masks); i++) {
 		list_for_each(pos, head) {
 			modelist = list_entry(pos, struct fb_modelist, list);
@@ -837,3 +833,44 @@ const struct fb_videomode *mxc_fb_find_nearest_mode(const struct fb_videomode *m
 }
 EXPORT_SYMBOL(mxc_fb_find_nearest_mode);
 
+void mxc_fb_var_to_videomode(struct fb_videomode *mode, const struct fb_var_screeninfo *var)
+{
+	u32 pixclock, hfreq, htotal, vtotal;
+
+	mode->name = NULL;
+	mode->xres = var->xres;
+	mode->yres = var->yres;
+	mode->pixclock = var->pixclock;
+	mode->hsync_len = var->hsync_len;
+	mode->vsync_len = var->vsync_len;
+	mode->left_margin = var->left_margin;
+	mode->right_margin = var->right_margin;
+	mode->upper_margin = var->upper_margin;
+	mode->lower_margin = var->lower_margin;
+	mode->sync = var->sync;
+	mode->vmode = var->vmode & FB_VMODE_MASK;
+	mode->flag = FB_MODE_IS_FROM_VAR;
+	mode->refresh = 0;
+
+	if (!var->pixclock)
+		return;
+
+	/* Note: mxcPICOS2KHZ() is not used here by purpose */
+	pixclock = PICOS2KHZ(var->pixclock) * 1000;
+
+	htotal = var->xres + var->right_margin + var->hsync_len +
+		var->left_margin;
+	vtotal = var->yres + var->lower_margin + var->vsync_len +
+		var->upper_margin;
+
+	if (var->vmode & FB_VMODE_DBLCLK)
+		htotal += var->xres;
+	if (var->vmode & FB_VMODE_INTERLACED)
+		vtotal /= 2;
+	if (var->vmode & FB_VMODE_DOUBLE)
+		vtotal *= 2;
+
+	hfreq = pixclock/htotal;
+	mode->refresh = hfreq/vtotal - ((var->vmode & FB_VMODE_FRACTIONAL) ? 1 : 0);
+}
+EXPORT_SYMBOL(mxc_fb_var_to_videomode);
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 42e7e06..0cd6474 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -1421,7 +1421,7 @@ static void hdmi_config_AVI(struct mxc_hdmi *hdmi)
 
 	dev_dbg(&hdmi->pdev->dev, "set up AVI frame\n");
 
-	fb_var_to_videomode(&mode, &hdmi->fbi->var);
+	mxc_fb_var_to_videomode(&mode, &hdmi->fbi->var);
 
 	if (!(mode.vmode & FB_VMODE_ASPECT_MASK)) {
 		if( mode.xres <= (mode.yres / 3) * 4)
@@ -1548,7 +1548,7 @@ static void hdmi_av_composer(struct mxc_hdmi *hdmi)
 
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
 
-	fb_var_to_videomode(&fb_mode, &fbi->var);
+	mxc_fb_var_to_videomode(&fb_mode, &fbi->var);
 
 	vmode->mHSyncPolarity = ((fb_mode.sync & FB_SYNC_HOR_HIGH_ACT) != 0);
 	vmode->mVSyncPolarity = ((fb_mode.sync & FB_SYNC_VERT_HIGH_ACT) != 0);
@@ -1971,6 +1971,10 @@ static void mxc_hdmi_create_modelist(struct mxc_hdmi *hdmi, int from_edid)
 
 		mode = mode_data[i];
 
+		/* TODO: double clocking currently not implemented in IPU */
+		if (mode.vmode & FB_VMODE_DBLCLK)
+			continue;
+
 		/* for dual aspect ratio modes, insert the first one only */
 		if (mode.vmode & FB_VMODE_ASPECT_MASK) {
 			skip = 0;
@@ -2066,7 +2070,7 @@ static void mxc_hdmi_set_mode(struct mxc_hdmi *hdmi, int edid_status)
 			fb_videomode_to_var(&var, mode);
 	}
 
-	fb_var_to_videomode(&m, &var);
+	mxc_fb_var_to_videomode(&m, &var);
 	dump_fb_videomode(&m);
 	mode = mxc_fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
 
@@ -2358,7 +2362,7 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
 
-	fb_var_to_videomode(&m, &hdmi->fbi->var);
+	mxc_fb_var_to_videomode(&m, &hdmi->fbi->var);
 	dump_fb_videomode(&m);
 
 	dev_dbg(&hdmi->pdev->dev, "%s - video mode changed\n", __func__);
@@ -2831,7 +2835,7 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 	fb_find_mode(&hdmi->fbi->var, hdmi->fbi,
 		     hdmi->dft_mode_str, NULL, 0,
 		     &vga_mode, hdmi->default_bpp);
-	fb_var_to_videomode(&m, &hdmi->fbi->var);
+	mxc_fb_var_to_videomode(&m, &hdmi->fbi->var);
 	if (m.vmode & FB_VMODE_INTERLACED)
 		m.refresh = (m.refresh / 2) - 2;
 	hdmi->dft_mode_set = false;
diff --git a/include/video/mxc_edid.h b/include/video/mxc_edid.h
index f00d142..b1b4b8e 100644
--- a/include/video/mxc_edid.h
+++ b/include/video/mxc_edid.h
@@ -31,6 +31,7 @@
 #define FB_VMODE_ASPECT_4_3	0x10
 #define FB_VMODE_ASPECT_16_9	0x20
 #define FB_VMODE_ASPECT_MASK	(FB_VMODE_ASPECT_4_3 | FB_VMODE_ASPECT_16_9)
+#define FB_VMODE_DBLCLK	0x40
 
 enum cea_audio_coding_types {
 	AUDIO_CODING_TYPE_REF_STREAM_HEADER	=  0,
@@ -111,4 +112,5 @@ int mxc_edid_parse_ext_blk(unsigned char *edid, struct mxc_edid_cfg *cfg,
 	struct fb_monspecs *specs);
 const struct fb_videomode *mxc_fb_find_nearest_mode(const struct fb_videomode *mode,
 						struct list_head *head);
+void mxc_fb_var_to_videomode(struct fb_videomode *mode, const struct fb_var_screeninfo *var);
 #endif
-- 
1.9.1


==============================================================
file 1124-video-mxc_edid-Unswap-margins-for-interlaced-modes.patch
==============================================================

From 078d552ed404599c968d13a560178fa874d748e4 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Wed, 30 Dec 2015 11:16:10 +0100
Subject: [PATCH] video: mxc_edid: Unswap margins for interlaced modes

The left/right and upper/lower margins for interlaced modes are swapped.

Signed-off-by: Rudi <r.ihle@s-t.de>
---
 drivers/video/mxc/mxc_edid.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index 3baac3c..e11fcd9 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -67,18 +67,18 @@ const struct fb_videomode mxc_cea_mode[64] = {
 	},
 	/* #5: 1920x1080i@59.94/60Hz 16:9 */
 	[5] = {
-		NULL, 60, 1920, 1080, 13468, 88, 148, 4, 31, 44, 10,
+		NULL, 60, 1920, 1080, 13468, 148, 88, 31, 4, 44, 10,
 		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
 	/* #6: 720(1440)x480iH@59.94/60Hz 4:3 */
 	[6] = {
-		NULL, 60, 720, 480, 37000, 38, 114, 8, 31, 124, 6, 0,
+		NULL, 60, 720, 480, 37000, 114, 38, 31, 8, 124, 6, 0,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3 | FB_VMODE_DBLCLK, 0,
 	},
 	/* #7: 720(1440)x480iH@59.94/60Hz 16:9 */
 	[7] = {
-		NULL, 60, 720, 480, 37000, 38, 114, 8, 31, 124, 6, 0,
+		NULL, 60, 720, 480, 37000, 114, 38, 31, 8, 124, 6, 0,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9 | FB_VMODE_DBLCLK, 0,
 	},
 	/* #8: 720(1440)x240pH@59.94/60Hz 4:3 */
@@ -125,18 +125,18 @@ const struct fb_videomode mxc_cea_mode[64] = {
 	},
 	/* #20: 1920x1080i@50Hz */
 	[20] = {
-		NULL, 50, 1920, 1080, 13468, 528, 148, 4, 31, 44, 10,
+		NULL, 50, 1920, 1080, 13468, 148, 528, 31, 4, 44, 10,
 		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
 	/* #21: 720(1440)x576i@50Hz */
 	[21] = {
-		NULL, 50, 720, 576, 37037, 24, 138, 4, 39, 126, 6, 0,
+		NULL, 50, 720, 576, 37037, 138, 24, 39, 4, 126, 6, 0,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3 | FB_VMODE_DBLCLK, 0,
 	},
 	/* #22: 720(1440)x576i@50Hz */
 	[22] = {
-		NULL, 50, 720, 576, 37037, 24, 138, 4, 39, 126, 6, 0,
+		NULL, 50, 720, 576, 37037, 138, 24, 39, 4, 126, 6, 0,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9 | FB_VMODE_DBLCLK, 0,
 	},
 	/* #23: 720(1440)x288pH@50Hz 4:3 */
-- 
1.9.1


==============================================================
file 1201-revert-edid-binary.patch
==============================================================

diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index dcda11b..210f6b4 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -310,12 +310,16 @@ static ssize_t mxc_hdmi_show_edid(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
-	int j;
+	int i, j, len = 0;
 
-	for (j = 0; j < HDMI_EDID_LEN; j++)
-		buf[j] = hdmi->edid[j];
+	for (j = 0; j < HDMI_EDID_LEN/16; j++) {
+		for (i = 0; i < 16; i++)
+			len += sprintf(buf+len, "0x%02X ",
+					hdmi->edid[j*16 + i]);
+		len += sprintf(buf+len, "\n");
+	}
 
-	return HDMI_EDID_LEN;
+	return len;
 }
 
 static DEVICE_ATTR(edid, S_IRUGO, mxc_hdmi_show_edid, NULL);

==============================================================
file 501-LIRC-avoid-keypress-duplication.patch
==============================================================

diff --git a/drivers/media/rc/rc-main.c b/drivers/media/rc/rc-main.c
index a74a931..705e2d6 100644
--- a/drivers/media/rc/rc-main.c
+++ b/drivers/media/rc/rc-main.c
@@ -31,7 +31,7 @@ extern void ledtrig_rc_activity(void);
 #define IR_TAB_MAX_SIZE	8192
 
 /* FIXME: IR_KEYPRESS_TIMEOUT should be protocol specific */
-#define IR_KEYPRESS_TIMEOUT 250
+#define IR_KEYPRESS_TIMEOUT 550
 
 /* Used to keep track of known keymaps */
 static LIST_HEAD(rc_map_list);

